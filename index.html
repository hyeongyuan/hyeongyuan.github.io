<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hyeongyuan.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="DevieW">
<meta property="og:url" content="https://hyeongyuan.github.io/index.html">
<meta property="og:site_name" content="DevieW">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Goofy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hyeongyuan.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>DevieW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DevieW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hyeongyuan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/04/01/typescript_study_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/01/typescript_study_3/" class="post-title-link" itemprop="url">타입스크립트 스터디 3주차</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-01 19:30:00" itemprop="dateCreated datePublished" datetime="2020-04-01T19:30:00+09:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-03 22:57:35" itemprop="dateModified" datetime="2020-04-03T22:57:35+09:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수-Funtion"><a href="#함수-Funtion" class="headerlink" title="함수 (Funtion)"></a>함수 (Funtion)</h1><p>함수는 애플리케이션의 코드를 구성하는 기본 요소입니다.</p>
<p>타입스크립트의 함수를 살펴보기 전에 먼제 자바스크립트의 함수를 간단히 살펴보고 지나가겠습니다.</p>
<h2 id="자바스크립트-함수"><a href="#자바스크립트-함수" class="headerlink" title="자바스크립트 함수"></a>자바스크립트 함수</h2><p>타입스크립트는 자바스크립트와 동일한 형태로 함수를 선언하고 호출할 수 있습니다.</p>
<p>자바스크립트의 함수는 두 가지로 나눌 수 있습니다.</p>
<ul>
<li>기명 함수 (Named function)</li>
<li>익명 함수 (Anonymous function)</li>
</ul>
<p>기명 함수는 <strong>3.1.1. var 선언자의 특징</strong>에서 언급했던 개념인 호이스팅(hoisting)이 발생합니다.</p>
<blockquote>
<p><strong>호이스팅</strong>이란 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상이다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">3</span> ,<span class="number">5</span>); <span class="comment">// 함수 선언하기 전에도 호출 가능 (호이스팅)</span></span><br><span class="line"><span class="comment">// Named function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>기명 함수와는 다르게 익명 함수는 호이스팅이 발생하지 않습니다. 그렇기 때문에 함수 선언 전에 함수를 호출하면 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substract(5, 3); // 함수 선언하기 전에는 호출 불가능</span></span><br><span class="line"><span class="comment">// Anonymous function</span></span><br><span class="line"><span class="keyword">let</span> substract = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;;</span><br><span class="line">substract(<span class="number">5</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="타입스크립트-함수"><a href="#타입스크립트-함수" class="headerlink" title="타입스크립트 함수"></a>타입스크립트 함수</h2><p>타입스크립트 또한 자바스크립트와 마찬가지로 기명 함수와 익명 함수로 함수를 생성할 수 있습니다.</p>
<h3 id="함수-타입"><a href="#함수-타입" class="headerlink" title="함수 타입"></a>함수 타입</h3><p>타입스크립트는 함수에도 타입을 선언할 수 있습니다. 타입 지정 대상은 함수로 전달되는 매개변수나 최종 반환되는 값이 될 수 있습니다. 이러한 타입 선언을 통해 타입 안전성을 강화합니다. 타입은 다음과 같이 선언합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>함수를 할당할 변수에 직접 타입 선언하는 것도 가능합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFunc: <span class="built_in">Function</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>기본적으로 타입스크립트에는 <code>Function</code>이라는 인터페이스가 내장되어있기 때문에 위와 같이 선언만 해도 함수 이외에 다른 값은 할당할 수 없습니다. 그러나 매개변수나 반환 값의 타입에 상관없이 어떤 함수라도 할당될 수 있기 때문에 타입 안정성이 완전히 확보되었다고 보기 힘듭니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFunc: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = add;</span><br></pre></td></tr></table></figure>

<h2 id="매개변수의-활용"><a href="#매개변수의-활용" class="headerlink" title="매개변수의 활용"></a>매개변수의 활용</h2><p>자바스크립트에서는 기본적으로 모든 함수가 가변적으로 인자를 받을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>타입스크립트에서는 기본적으로 가변 변수를 허용하지 않습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// Error: Expected 2 arguments, but got 1.</span></span><br></pre></td></tr></table></figure>

<p>하지만 이렇게 정해진 숫자의 인자만 받을 수 있다면 유연성이 떨어져서 개발하는 과정에서 불편함이 발생합니다.</p>
<p>타입스트립트 함수에 정해진 타입과 정해진 수의 인자를 넘기지 않으면 에러를 발생시키므로 함수를 선언할 때 어느 정도의 유연성을 확보해야 함수 오버로딩을 구현할 수 있습니다. 이러한 인자 갯수의 유연성을 확보하는 방법을 이어서 살펴 보겠습니다.</p>
<h2 id="기본-초기화-매개변수"><a href="#기본-초기화-매개변수" class="headerlink" title="기본 초기화 매개변수"></a>기본 초기화 매개변수</h2><p>타입스크립트 ES6에서 추가된 기본 초기화 매개변수(default-initialized parameter)는 함수의 특정 매개변수에 인수가 전달되지 않으면 매개변수에 설정된 초기값으로 초기화하는 기능입니다.</p>
<p>ES6 이전의 자바스크립트에서 매개변수로 넘겨받는 값의 초기값을 설정해주고 싶었다면 보통 다음과 같이 할 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomthing</span>(<span class="params">whatever</span>) </span>&#123;</span><br><span class="line">  whatever = whatever || <span class="string">'whatever'</span>; <span class="comment">/* 초기값 설정 */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6와 타입스크립트에서는 이렇게 합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">whatever = 'whatever' <span class="comment">/* 초기값 설정 */</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>타입스크립트에서는 Default 값을 주는 경우에는 타입을 선언하지 않아도 인자의 타입을 추론하므로 선언을 생략해도 무방합니다.</p>
<p>아래 코드는 기본 초기화 매개변수를 사용한 간단한 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalPhoneNumber</span>(<span class="params"><span class="built_in">number</span>: <span class="built_in">string</span>, countryCode = '+82'</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;countryCode&#125;</span><span class="subst">$&#123;<span class="built_in">number</span>.slice(<span class="number">1</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalPhoneNumber(<span class="string">'01015888282'</span>); <span class="comment">// +821015888282</span></span><br><span class="line">globalPhoneNumber(<span class="string">'01015774949'</span>, <span class="string">'+04'</span>); <span class="comment">// +041015774949</span></span><br></pre></td></tr></table></figure>

<h2 id="나머지-매개변수"><a href="#나머지-매개변수" class="headerlink" title="나머지 매개변수"></a>나머지 매개변수</h2><p>나머지 매개변수(rest parameter)는 ES6에서 제안된 특징으로 개수가 정해지지 않은 인수(arguments)를 배열(array)로 받을 수 있는 기능입니다. 이는 <code>...</code>라는 표기법을 통해 나머지 매개변수에 접근할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">...restParameter <span class="regexp">/* 나머지 매개변수 */</span></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>나머지 매개변수는 0개 이상의 요소를 받을 수 있습니다. 따라 위 예제의 concat 함수를 호출하려면 최소한 0개 이상의 인수를 전댈해야 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">...restParameter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> restParameter.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(concat(<span class="string">'a'</span>, <span class="number">1</span>, <span class="literal">true</span>, &#123;&#125;)); <span class="comment">// a1true&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>위의 concat 함수에 선언된 나머지 매개변수는 타입이 없기 때문에 타입 구분없이 여러 인수를 전달받아 문자열 합치기를 수행합니다. 그러나 이를 의도하고 구현하는 경우는 극히 드물 것입니다. 보통은 문자열 배열을 하나의 문자열로 만들기 위해 위와 같은 함수를 이용할 것입니다. 이런 경우에는 나머지 매개변수에 타입을 추가해 지정한 타입의 인수만을 받도록 제한할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">...restParameter: <span class="built_in">string</span>[]  <span class="comment">/* 나머지 매개변수 타입 */</span></span>): <span class="title">string</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="선택-매개변수"><a href="#선택-매개변수" class="headerlink" title="선택 매개변수"></a>선택 매개변수</h2><p>앞에서 살펴본 나머지 매개변수를 선언하여 가변적으로 인자를 받을 수 있었습니다. 그런데 나머지 매개변수는 최대 개수가 정해져 있지 않기 때문에 불필요한 인수들이 함께 전달될 수 있습니다. 예를 들어 인수의 개수를 1개 혹은 2개로 제한하기 위해서는 ‘선택 매개변수(optional parameter)’를 이용해야 합니다.</p>
<p>선택 매개변수는 변수명 뒤에 물음표(<code>?</code>)를 붙이는 식으로 선언합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>앞서 기본 초기화 매개변수를 이용해 인수가 생략돼 있을 때 매개변수의 초기값을 설정할 수 있었습니다. 그런데 이 방법은 선택 매개변수와 결합해서 사용할 수 없습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span> = 2 <span class="comment">/* 함깨 사용 불가 */</span></span>):<span class="title">number</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>아래 코드는 선택 매개변수를 사용한 간단한 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeProfile</span>(<span class="params">name: <span class="built_in">string</span>, toUpper?: <span class="built_in">boolean</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> username = name;</span><br><span class="line">  <span class="keyword">if</span> (toUpper) &#123;</span><br><span class="line">    username = username.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;username&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeProfile(<span class="string">'thomas'</span>); <span class="comment">// hello, thomas</span></span><br><span class="line">makeProfile(<span class="string">'hyeonyu'</span>, <span class="literal">true</span>); <span class="comment">// hello, HYEONGYU</span></span><br><span class="line">makeProfile(<span class="string">'goofy'</span>, <span class="literal">false</span>, <span class="number">1</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h2 id="함수-오버로드"><a href="#함수-오버로드" class="headerlink" title="함수 오버로드"></a>함수 오버로드</h2><p>함수 오버로드(function overloads)는 함수명은 같지만, 매개변수와 반환 타입이 다른 함수를 여러개 선언 할 수 있는 특징을 말합니다. 컴파일 시간에 가장 적합한 오버로드를 선택해 컴파일 함으로 자바스크립 실행 시 런타임 비용이 발생하지 않습니다. 오버로드는 다음과 같이 목록 형태로 선언할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 올바른 예 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>유의해야할 점은 타입스크립트는 자바스크립트로 변환되고 나서도 동일한 형태를 유지해야 한다는 것입니다. 따라서 각 오버로드는 다음처럼 독립된 블록으로 선언하면 안됩니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 잘못된 예 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>가장 일반적인(general) 함수 (매개변수를 any 타입으로 선언)의 시그니처를 가장 아래에 선언하고 그 위로 구체적인(specific) 타입을 명시한 함수의 시그니처를 쌓는 방식으로 선언해야 합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'hello '</span>, <span class="string">'world!'</span>)); <span class="comment">// hello world!</span></span><br></pre></td></tr></table></figure>

<p>이때 매개변수의 갯수가 다른 오버로드를 지정할 때는 선택 매개변수를 둬 매개변수 갯수에 변화를 줄 수 있도록 허용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">any</span>, b?: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      ...   <span class="comment">// 두번째 인자의 값이 없는 경우</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="유니언-타입"><a href="#유니언-타입" class="headerlink" title="유니언 타입"></a>유니언 타입</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">x: &#123; name: <span class="built_in">string</span> &#125;</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pack</span>(<span class="params">x: &#123; month: <span class="built_in">number</span>&#125;</span>) : <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>오버로드로 선언된 함수는 다양한 타입의 인수를 받고 반환 타입도 여러 개입니다. 이처럼 함수의 매개변수와 반환 타입이 다양한 경우에 유니언 타입 형태로도 표현 가능합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">x: <span class="built_in">number</span> | &#123;name: <span class="built_in">string</span>&#125; | &#123;name: <span class="built_in">number</span>&#125;</span>) <span class="title">number</span> | <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="객체-리터럴의-선언과-객체-리터럴-타입의-선언"><a href="#객체-리터럴의-선언과-객체-리터럴-타입의-선언" class="headerlink" title="객체 리터럴의 선언과 객체 리터럴 타입의 선언"></a>객체 리터럴의 선언과 객체 리터럴 타입의 선언</h2><p>객체 리터럴의 hello 속성에 선언된 함수는 함수 내부의 스코프에서 다른 객체 속성에 접근하려 할 때 코드 어시스트가 동작하지 않습니다.</p>
<p><img src="/images/typescript_1.png" alt="windows-telnet-1"></p>
<p>인터페이스를 이용해 객체 리터럴의 타입을 추가하고 첫 번째 매개변수로 <code>this</code>를 선언하여(반드시 첫 번째 매개변수로 선언해야 한다.) 내부 참조 시에도 코드 어시스트가 동작하도록 할 수 있습니다.</p>
<p><img src="/images/typescript_2.png" alt="windows-telnet-2"></p>
<p>컴파일 후에는 타입들은 물론이고 첫 번째 매개변수(this)도 함께 사라집니다.</p>
<p>객체 내부 함수에서 다른 속성에 접근하려면 인터페이스를 선언한 다음에 this에 객체 리터럴의 타입을 추개해야 합니다. 만약 this에 타입을 강제해서 추가하려면 tsconfig.json의 컴파일 옵션에 <code>noImplicitThis: true</code> 속성을 추가하면 됩니다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"compilerOptions": &#123;</span><br><span class="line">  "noImplicitThis": true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/03/22/typescript_study_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/typescript_study_2/" class="post-title-link" itemprop="url">타입스크립트 스터디 2주차</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-22 19:30:00" itemprop="dateCreated datePublished" datetime="2020-03-22T19:30:00+09:00">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-03 23:00:26" itemprop="dateModified" datetime="2020-04-03T23:00:26+09:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-1-조건문의-타입-제약과-폴스루"><a href="#4-1-조건문의-타입-제약과-폴스루" class="headerlink" title="4.1. 조건문의 타입 제약과 폴스루"></a>4.1. 조건문의 타입 제약과 폴스루</h1><p><strong>조건문</strong>이란 특정 조건을 만족할 때 코드가 실행되게 하는 구문을 말합니다. 타입스크립트는 자바스크립트에서 사용했던 조건문을 사용할 수 있습니다. 대표적인 문법으로 <code>if</code> 문과 <code>switch</code> 문이 있습니다.</p>
<h2 id="4-1-1-if-문-사용-시-타입-제약"><a href="#4-1-1-if-문-사용-시-타입-제약" class="headerlink" title="4.1.1 if 문 사용 시 타입 제약"></a>4.1.1 if 문 사용 시 타입 제약</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">if (조건) &#123;</span><br><span class="line">  명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> condition: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (conditon) &#123;</span><br><span class="line">  <span class="comment">// do somthing...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if 문에 지정하는 조건이 참(true)이면 다음 <code>{}</code> 안의 코드가 실행됩니다. 그런데 if 문의 조건값으로 <code>boolean</code> 타입만이 올 수 있는 것이 아닙니다. 이는 if 문의 조건을 판단하는 방식이 <code>==</code> 비교 연산자와 동일하기 때문입니다. <code>0, -0, null, false, NaN, undefined, &#39;&#39;</code> 의 값을 가지면 거짓(false)이고 나머지 값은 전부 참입니다.</p>
<p>예외적으로 <code>false == []</code> 는 <code>true</code> 이지만 if 문의 조건에는 참으로 인식되기 때문에 사용에 주의해야 합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val: <span class="built_in">string</span> = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Value is '</span> + value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Empty string!!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>간단한 <code>if else</code> 문은 삼항 연산자로 간결하게 표현할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val: <span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> isBiggerThanFive: <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">if</span> (val &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  isBiggerThanFive = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  isBiggerThanFive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 삼항 연산자</span></span><br><span class="line">isBiggerThanFive = val &gt; <span class="number">5</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-2-switch-문과-폴스루"><a href="#4-1-2-switch-문과-폴스루" class="headerlink" title="4.1.2. switch 문과 폴스루"></a>4.1.2. switch 문과 폴스루</h2><p><code>switch</code> 문은 비교할 대상이 많을 때 단순한 형태로 비교를 수행하기 위해 사용합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">switch (표현식) &#123;</span><br><span class="line">  case 값1:</span><br><span class="line">    명령문;</span><br><span class="line">    break;</span><br><span class="line">  case 값2:</span><br><span class="line">    명령문;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    명령문;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 문의 표현식에는 변수가 올 수 있고 표현식의 값과 일치하는 case 절이 실행됩니다. 타입스크립트는 case 절에 선언한 값의 타입과 표현식에 사용할 변수의 타입이 일치하도록 강제합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (val) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is '</span>, val);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'1'</span>: <span class="comment">// error TS2678: Type 'string' is not comparable to type 'number'.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is '</span>, val);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 case 절 값의 타입이 하나로 정해지지 않다면 <code>any</code> 타입을 이용해 타입 제한을 없앨 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val: <span class="built_in">any</span> = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">switch</span> (val) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is number type.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is string type.'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>따라서 swtich 문을 사용할 때 case 절에 사용할 타입이 고정적이라면 반드시 입력 변수에 타입을 선언해야 하고, 그렇지 않다면 any 타입을 지정해야 합니다.</p>
<h3 id="폴스루에-대한-이해와-폴스루의-사용-여부-설정"><a href="#폴스루에-대한-이해와-폴스루의-사용-여부-설정" class="headerlink" title="폴스루에 대한 이해와 폴스루의 사용 여부 설정"></a>폴스루에 대한 이해와 폴스루의 사용 여부 설정</h3><p>case 절에서 break 문을 생략하여 다음 case 절이 실행되는 현상을 <strong>폴스루(fall-through)</strong> 라고 합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (input % <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is 0'</span>); <span class="comment">// fall-through 발생</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is 1'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Value is 0</span></span><br><span class="line"><span class="comment">// Value is 1</span></span><br></pre></td></tr></table></figure>

<p>폴스루는 case 절을 처리할 때 여러 case 절에서 처리하는 로직이 같은 경우에 고의로 발생시키는 경우가 있습니다. 반대로 개발자의 실수로 break 문을 생략하여 폴스루 현상이 발생하기도 합니다. 만일 이러한 실수를 방지하고 싶다면 tsc 컴파일러 옵션에 <code>&quot;noFallthroughCasesInSwitch&quot;: true</code> 를 설정하면 됩니다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>예외적으로 noFallthroughCasesInSwitch 옵션을 true 로 설정하더라도 폴스루를 허용하는 방법이 있습니다. 바로 case 절에 아무런 명령문도 넣지 않는 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Value is 1'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Value is 1</span></span><br></pre></td></tr></table></figure>

<p>위의 예제는 폴스루가 발생하지만 noFallthroughCasesInSwitch 옵션을 true 로 설정해도 컴파일에 성공합니다.</p>
<h1 id="4-2-반복문의-다양한-사용법"><a href="#4-2-반복문의-다양한-사용법" class="headerlink" title="4.2. 반복문의 다양한 사용법"></a>4.2. 반복문의 다양한 사용법</h1><h2 id="4-2-1-for-문과-이터러블-객체"><a href="#4-2-1-for-문과-이터러블-객체" class="headerlink" title="4.2.1. for 문과 이터러블 객체"></a>4.2.1. for 문과 이터러블 객체</h2><p>지금부터 타입스크립트에서 지원하는 여러 for 문을 살펴보겠습니다.</p>
<h3 id="기본적인-for-문"><a href="#기본적인-for-문" class="headerlink" title="기본적인 for 문"></a>기본적인 for 문</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">for (변수 초기화; 조건식; 증감식) &#123;</span><br><span class="line">  명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 문에서 사용할 변수 ES6에서 지원되는 <code>let</code> 키워드와 타입을 지정할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'i: '</span>, i); <span class="comment">// output: i: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Typescript</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j: <span class="built_in">number</span>; j &lt; <span class="number">2</span>; j++) &#123;&#125;</span><br><span class="line"><span class="comment">// console.log('j: ', j);</span></span><br></pre></td></tr></table></figure>

<p>ES5 for 문에서는 카운터 변수 i가 <code>var</code> 선언자로 선언돼 있습니다. 따라서 for 문에 블록 레벨 스코프가 적용되지 않아 for 문에서 초기화 변수를 for 문 밖에서도 사용할 수 있습니다. 반면 타입스크립트 for 문은 카운터 변수 j에 <code>number</code> 타입을 지정해 타입 안전성을 강화했고, 동시에 ES6의 <code>let</code> 선언자로 선언해 for 문 내부에서만 사용되도록 블록 레벨 스코프가 적용됩니다. 따라서 타입스크립트 for 문을 벗어나면 카운터 변수 j를 사용할 수 없습니다.</p>
<p>따라서 for 문을 사용할 때는 <code>let</code> 선언자를 이용해 블록 레벨 스코프를 적용하고, 타입을 추가해 타입 안정성을 확보하는 것이 좋습니다.</p>
<h3 id="ES5의-for-in-문"><a href="#ES5의-for-in-문" class="headerlink" title="ES5의 for in 문"></a>ES5의 for in 문</h3><p><code>for in</code> 문은 ES5의 자바스크립트에서 배열이나 객체를 순회할 때 사용했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cities = [<span class="string">'Seoul'</span>, <span class="string">'Daejun'</span>, <span class="string">'Daegu'</span>, <span class="string">'Busan'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> cities) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, cities[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 Seoul</span></span><br><span class="line"><span class="comment">// 1 Daejun</span></span><br><span class="line"><span class="comment">// 2 Daegu</span></span><br><span class="line"><span class="comment">// 3 Busan</span></span><br></pre></td></tr></table></figure>

<p>만일 인덱스가 숫자가 아닌 키라고 한다면 객체 리터럴을 이용하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = &#123; <span class="attr">a</span>: <span class="string">'apple'</span>, <span class="attr">b</span>: <span class="string">'banana'</span>, <span class="attr">c</span>: <span class="string">'cherry'</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> fruits) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(property, fruits[property]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a apple</span></span><br><span class="line"><span class="comment">// b banana</span></span><br><span class="line"><span class="comment">// c cherry</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6의-for-of-문"><a href="#ES6의-for-of-문" class="headerlink" title="ES6의 for of 문"></a>ES6의 for of 문</h3><p><code>for of</code> 문은 ES6 표준에 추가된 특징으로 타입스크립트 1.5부터 지원됩니다. 인덱스를 이용해 값을 가져오는 for in 문과 달리 for of 문은 곧바로 값을 가져올 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">for (변수 of 이터러블) &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터러블(iterable)은 반복 가능한 객체인 배열, 문자열, DOM 컬렉션, 맵(Map)과 셋(Set) 등을 말합니다. 이러한 이터러블은 for of 문을 이용해 각 값을 가져올 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="string">'hi'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>여기서 눈여겨볼 점은 let 선언자가 아닌 <code>const</code>를 사용한 점입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">// for (const i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">//                          ^</span></span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>위의 예제와 같이, 일반 for 문에서는 let 선언자가 아닌 const를 사용할 수 없습니다. 그런데 for of 문은 <code>Symbol.iterator</code>의 구현을 통해 각 이터레이션 값의 요소를 가져오기 때문에 const를 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value of [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for of 문은 ES6에 추가된 특징이지만 ES5 버전으로도 문제 없이 컴파일됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsc for_of.ts -t ES5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>, _a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; _i &lt; _a.length; _i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = _a[_i];</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같은 경우에는 이터러블 객체인 배열이 제대로 변환이 되었지만, 불가피하게 ES5로 변환되지 못하는 객체가 있습니다. 바로 맵과 셋입니다.</p>
<h3 id="맵과-셋을-for-of-문에-적용"><a href="#맵과-셋을-for-of-문에-적용" class="headerlink" title="맵과 셋을 for of 문에 적용"></a>맵과 셋을 for of 문에 적용</h3><p>ES6에 추가된 이터러블 객체로 맵(Map)과 셋(Set)이 있습니다. 맵과 셋은 tsconfig.json 파일의 target 속성값이 ES5이면 컴파일되지 않습니다. 이는 ES5에 맴과 셋에 대응할 만한 문법이 존재하지 않기 때문입니다. 그렇기 때문에 맵과 셋을 이용하는 for of 문을 정상적으로 실행하기 위해서는 target 속성값을 <strong>ES2015 혹은 그 이후의 버전</strong>으로 수정해야 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsc map.ts -t ES2015</span></span><br><span class="line"><span class="keyword">let</span> isMap = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'one'</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">'two'</span>, <span class="number">2</span>],</span><br><span class="line">]);</span><br><span class="line">isMap.set(<span class="string">'one'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> isMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isMap.get(<span class="string">'one'</span>));</span><br><span class="line"><span class="comment">// ['one', 3]</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>위의 예제에서 볼 수 있듯이, 맵 객체는 <strong>키의 중복을 허용하지 않는 특성</strong>이 있습니다. 또한 키-값 기반이기 때문에 키를 이용해 값을 가져올 수 있습니다.</p>
<p>맵 객체는 ES6부터 사용할 수 있기 때문에 ES5에서 맵의 기능을 이용하려면 별도의 맵을 구현해야 합니다. 아래에는 키의 중복을 허용하지 않는 맵의 특성을 간단한 객체 리터럴을 이용해 구현한 예시입니다. 객체 리터럴은 타입 지정이 가능하므로 맵에 사용할 키와 값에 대한 타입을 추가해 <strong>타입 안전성</strong>을 확보할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleMap: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">number</span> &#125; = &#123;&#125;;</span><br><span class="line">simpleMap[<span class="string">'one'</span>] = <span class="number">1</span>;</span><br><span class="line">simpleMap[<span class="string">'one'</span>] = <span class="number">2</span>;</span><br><span class="line">simpleMap[<span class="string">'one'</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">in</span> simpleMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([entry, simpleMap[entry]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(simpleMap[<span class="string">'one'</span>]);</span><br></pre></td></tr></table></figure>

<p>위에 선언한 타입은 컴파일 후에는 사라지게 됩니다.</p>
<p>이어서 살펴볼 셋(Set) 객체는 어떤 타입의 값이든 유일한 값을 저장할 수 있는 특성이 있습니다. 셋 객체 또한 타입스크립트 컴파일 target 속성값이 ES2015 혹은 그 이후의 버전일 때 컴파일이 가능합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isSet = <span class="keyword">new</span> Set([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value of isSet) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tsc <span class="built_in">set</span>.ts -t ES5</span><br><span class="line"><span class="function">set.ts:1:17 - <span class="title">error</span> <span class="title">TS2583</span>: <span class="title">Cannot</span> <span class="title">find</span> <span class="title">name</span> '<span class="title">Set</span>'. <span class="title">Do</span> <span class="title">you</span> <span class="title">need</span> <span class="title">to</span> <span class="title">change</span> <span class="title">your</span> <span class="title">target</span> <span class="title">library</span>? <span class="title">Try</span> <span class="title">changing</span> <span class="title">the</span> `<span class="title">lib</span>` <span class="title">compiler</span> <span class="title">option</span> <span class="title">to</span> <span class="title">es2015</span> <span class="title">or</span> <span class="title">later</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">1 <span class="title">let</span> <span class="title">isSet</span> = <span class="title">new</span> <span class="title">Set</span>(['<span class="title">a</span>', '<span class="title">b</span>', '<span class="title">c</span>', '<span class="title">a</span>', '<span class="title">b</span>']);</span></span><br><span class="line"><span class="function">                  ~~~</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span>.</span></span><br></pre></td></tr></table></figure>

<p>셋은 맵과 달리 키-값 기반이 아니라 값만을 다루기 때문에 get 메서드를 제공하고 있지 않습니다. 따라서 셋 객체는 값을 추가하거나(add), 값을 비우거나(clear), 값을 삭제하는 것(delete)과 같이 키가 아닌 값을 다루는 메서드를 제공하고 있습니다.</p>
<h3 id="Symbol-iterator-메서드를-이용한-이터러블-객체-사용"><a href="#Symbol-iterator-메서드를-이용한-이터러블-객체-사용" class="headerlink" title="[Symbol.iterator]() 메서드를 이용한 이터러블 객체 사용"></a>[Symbol.iterator]() 메서드를 이용한 이터러블 객체 사용</h3><p>[Symbol.iterator]() 메서드는 ES6에 추가된 특징으로 배열, 맵, 셋과 같은 이터러블 객체(iterable object)를 순회하는 데 사용합니다. 내부적으로 사용하는 특징으로 실제로 실전에서 사용할 일은 많지 않지만, 사용자가 새로운 이터러블 객체를 만들어 for of, for in 문에 적용하려면 [Symbol.iterator]() 메서드를 이용해 이터러블 객체로 구현해야 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> isObj = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1:'</span>, <span class="keyword">typeof</span> isObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2:'</span>, isObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3:'</span>, isObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4:'</span>, isObj.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1: object</span></span><br><span class="line"><span class="comment">// 2: &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 3: &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">// 4: &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-2-while-문과-do-while-문"><a href="#4-2-2-while-문과-do-while-문" class="headerlink" title="4.2.2. while 문과 do-while 문"></a>4.2.2. while 문과 do-while 문</h2><h3 id="while-문"><a href="#while-문" class="headerlink" title="while 문"></a>while 문</h3><p>타입스크립트의 while 문은 자바스크립트의 ES5와 동일한 문법을 사용합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">while (참&#x2F;거짓을 판별할 수 있는 조건문) &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sum: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">continue</span>) &#123;</span><br><span class="line">    sum += count;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5050</span></span><br></pre></td></tr></table></figure>

<h3 id="do-while-문"><a href="#do-while-문" class="headerlink" title="do-while 문"></a>do-while 문</h3><p>타입스크립트의 do-while 문은 자바스크립트 ES5와 동일합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">do &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br><span class="line">while(반복 조건);</span><br></pre></td></tr></table></figure>

<p>do-while문은 while 문과 달리 명령문을 먼저 실행하고 조건을 검사하기 때문에 최소한 한 번 이상은 명령문의 실행이 보장된다는 특징이 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cnt: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(cnt);</span><br><span class="line">  cnt++;</span><br><span class="line">&#125; <span class="keyword">while</span> (cnt != <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h1 id="5-1-기본-연산자"><a href="#5-1-기본-연산자" class="headerlink" title="5.1. 기본 연산자"></a>5.1. 기본 연산자</h1><h2 id="5-1-1-산술-연산자"><a href="#5-1-1-산술-연산자" class="headerlink" title="5.1.1. 산술 연산자"></a>5.1.1. 산술 연산자</h2><p>타입스크립트는 자바스크립트와 동일한 산술 연산자(arithmetic operator)를 지원합니다. 산술 연산자로는 더하기, 빼기, 곱하기, 나누기 같은 사칙연산과 나머지 연산을 수행할 수 있는 <code>%</code> 연산자가 있습니다. 이에 더해 타입스크립트는 ES7의 지수 연산자 (exponentiation operator)인 <code>**</code>를 지원하므로 <code>Math.pow</code>를 대체해 사용할 수 있습니다.</p>
<p>타입이 다른 피연산자 간의 더하기 연산 중에 문자열 간의 더하기 연산은 타입스크립트 또한 자바스크립트처럼 문자열 결합(concatenation)으로 인식합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">'happy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="string">'happy'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1happy</span></span><br><span class="line"><span class="comment">// falsehappy</span></span><br></pre></td></tr></table></figure>

<p>그런데 타입스크립트에는 더하기 연산자를 허용하지 않는 예외 상황이 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + false</span><br></pre></td></tr></table></figure>

<p>위와 같은 연산식을 자바스크립트에서는 false 값을 0으로 인식해 정상적으로 실행하며 결과는 1이 됩니다. 그런데 타입스크립트에서는 타입 오류로 판별합니다.</p>
<p>타입스크립트에서는 숫자 값과 불리언 값은 연산할 수 없으며, 자바스크립트처럼 false 값을 0으로 인식하지 않습니다. 따라서 숫자 값과 불리언 값의 연산은 물론 불리언 값끼리의 연산식도 타입 오류가 발생합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false + false</span><br></pre></td></tr></table></figure>

<p>또한, 산술 연산자를 사용할 때 자바스크립트보다 엄격하게 타입을 검사하는 부분이 있습니다. 타입스크립트에서는 문자열 타입의 숫자를 연산식에 사용할 수 없습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 &#x2F; &quot;2&quot;</span><br></pre></td></tr></table></figure>

<p>자바스크립트에서 위 식은 정상적으로 실행되며 5를 출력합니다. 그러나 타입스크립트는 문자열 타입을 연산에 허용하지 않으므로 타입 오류가 발생합니다.</p>
<p>이처럼 타입스크립트는 산술 연산자를 사용할 때 엄격한 타입 검사를 함으로써 연산의 안전성을 높입니다.</p>
<h2 id="5-1-2-비교-논리-조건-연산자"><a href="#5-1-2-비교-논리-조건-연산자" class="headerlink" title="5.1.2. 비교, 논리, 조건 연산자"></a>5.1.2. 비교, 논리, 조건 연산자</h2><p>타입스크립트에서 조건문에 사용할 수 있는 연산자는 크게 세 가지가 있습니다.</p>
<ul>
<li>비교 연산자</li>
<li>논리 연산자</li>
<li>조건 연산자</li>
</ul>
<p>비교 연산자로는 다음과 같은 연산자가 있습니다.</p>
<table>
<thead>
<tr>
<th>연산자 기호</th>
<th>연산 예</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>a == b</td>
<td>a와 b의 값이 같은지 비교</td>
</tr>
<tr>
<td>===</td>
<td>a === b</td>
<td>a와 b의 값과 타입이 모두 같은지 비교</td>
</tr>
<tr>
<td>!=</td>
<td>a != b</td>
<td>a와 b의 값이 다른지 비교</td>
</tr>
<tr>
<td>!==</td>
<td>a !== b</td>
<td>a와 b의 값과 타입이 모두 다른지 비교</td>
</tr>
</tbody></table>
<p>자바스크립트는 피연산자 간에 타입이 달라도 비교할 수 있습니다. 예를 들어, <code>1 == true, 1 == &quot;1&quot;</code>과 같이 타입이 달라도 비교 연산(결과는 모두 true)이 가능합니다. 그런데 타입스크립트는 피연산자 간에 타입이 다르면 연산을 허용하지 않습니다.</p>
<p>이는 피연산자 간의 비교 연산을 할 때 타입 안전성을 고려하기 때문입니다. 따라서 타입스크립트는 <code>true == false</code>와 같이 타입이 같은 피연산자 간의 비교 연산만 허용합니다. 특히 타입스크립트는 “==” 연산자 대신 “===”을, “!=” 연산자 대신 “!==”을 사용하기를 권장합니다. 왜냐하면 “===”, “!==” 연산자를 사용해야 자바스크립트로 컴파일하고 나서도 타입 안전성이 보장되기 때문입니다.</p>
<p>논리 연산자로는 다음 세 가지가 있습니다.</p>
<ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>! (부정 연산자)</li>
</ul>
<p>마지막으로 조건 연산자(?:)는 피연산자 3개를 사용하는 삼항 연산자(tenary operator)입니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">판별 조건 ? 표현식1 : 표현식2</span><br></pre></td></tr></table></figure>

<h3 id="불리언-타입과-부정-연산자"><a href="#불리언-타입과-부정-연산자" class="headerlink" title="불리언 타입과 부정 연산자"></a>불리언 타입과 부정 연산자</h3><h1 id="5-2-디스트럭처링"><a href="#5-2-디스트럭처링" class="headerlink" title="5.2. 디스트럭처링"></a>5.2. 디스트럭처링</h1><h2 id="5-2-1-객체-디스트럭처링"><a href="#5-2-1-객체-디스트럭처링" class="headerlink" title="5.2.1. 객체 디스트럭처링"></a>5.2.1. 객체 디스트럭처링</h2><h3 id="객체-디스트럭처링의-기본"><a href="#객체-디스트럭처링의-기본" class="headerlink" title="객체 디스트럭처링의 기본"></a>객체 디스트럭처링의 기본</h3><h3 id="디스트럭처링-매개변수-선언"><a href="#디스트럭처링-매개변수-선언" class="headerlink" title="디스트럭처링 매개변수 선언"></a>디스트럭처링 매개변수 선언</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printProfile</span>(<span class="params">&#123; name, nationality = <span class="string">'?'</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(nationality);</span><br><span class="line">&#125;</span><br><span class="line">printProfile(&#123; <span class="attr">name</span>: <span class="string">'thomas'</span> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="객체-디스트럭처링-시-type-키워드-활용"><a href="#객체-디스트럭처링-시-type-키워드-활용" class="headerlink" title="객체 디스트럭처링 시 type 키워드 활용"></a>객체 디스트럭처링 시 type 키워드 활용</h3><h2 id="5-2-2-배열-디스트럭처링"><a href="#5-2-2-배열-디스트럭처링" class="headerlink" title="5.2.2. 배열 디스트럭처링"></a>5.2.2. 배열 디스트럭처링</h2><h3 id="배열-요소를-함수의-디스트럭처링-매개변수로-전달"><a href="#배열-요소를-함수의-디스트럭처링-매개변수로-전달" class="headerlink" title="배열 요소를 함수의 디스트럭처링 매개변수로 전달"></a>배열 요소를 함수의 디스트럭처링 매개변수로 전달</h3><h1 id="5-3-전개-연산자"><a href="#5-3-전개-연산자" class="headerlink" title="5.3. 전개 연산자"></a>5.3. 전개 연산자</h1><p>###</p>
<p>타입스크립트는 ES6의 전개 연산자(spread operator)를 지원합니다.</p>
<ul>
<li>나머지 매개변수를 선언할 때</li>
<li>배열 요소를 확장할 때</li>
<li>객체 요소를 확장할 때</li>
</ul>
<p>합치기(concatennation)와 디스트럭처링(destructuring)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, ...rest &#125; = userInfo;</span><br><span class="line"><span class="keyword">delete</span> rest.password;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123; <span class="attr">id</span>: rest &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-1-전개-연산자를-이용한-배열-요소-확장"><a href="#5-3-1-전개-연산자를-이용한-배열-요소-확장" class="headerlink" title="5.3.1. 전개 연산자를 이용한 배열 요소 확장"></a>5.3.1. 전개 연산자를 이용한 배열 요소 확장</h3><h3 id="5-3-2-전개-연산자를-이용한-객체-요소-확장"><a href="#5-3-2-전개-연산자를-이용한-객체-요소-확장" class="headerlink" title="5.3.2. 전개 연산자를 이용한 객체 요소 확장"></a>5.3.2. 전개 연산자를 이용한 객체 요소 확장</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b, ...c &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// &#123; c: 30, d:40 &#125;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/03/12/typescript_study_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/typescript_study_1/" class="post-title-link" itemprop="url">타입스크립트 스터디 1주차</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 19:30:00" itemprop="dateCreated datePublished" datetime="2020-03-12T19:30:00+09:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-03 22:57:37" itemprop="dateModified" datetime="2020-04-03T22:57:37+09:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="tsconfig-js"><a href="#tsconfig-js" class="headerlink" title="tsconfig.js"></a>tsconfig.js</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 초기 세팅</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compilerOptions</code> 프로퍼티는 컴파일 옵션을 설정한다. 생략한 경우에는 기본 컴파일 옵션이 적용된다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>컴파일 대상 파일을 지정하기 위해서 <code>files</code> 또는 <code>include</code> 프로퍼티를 사용한다. 만약 <code>files</code> 프로퍼티를 정의하였다면 <code>include</code> 프로퍼티는 무시된다.</p>
<p><code>files</code> 프로퍼티에는 컴파일 대상 파일의 상대 경로 또는 절대 경로를 명시적으로 설정한다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files"</span>: [<span class="string">"src/file_one.ts"</span>, <span class="string">"src/file_two.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>include</code> 프로퍼티에는 컴파일 대상 파일 리스트를 설정한다. <code>exclude</code> 프로퍼티에는 컴파일 대상에서 제외할 파일 리스트를 설정한다.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src/**/*"</span>],</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"**/*.spec.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src/\*\*/\*</code>는 src 폴더 내에 있는 모든 서브 폴더 내의 모든 파일(.ts, .tsx)을 의미한다. 컴파일 옵션 <code>&quot;allowJs&quot;: true</code>를 설정하면 .js와 .jsx 파일도 컴파일 대상이 된다.</p>
<h1 id="3-1-변수-선언"><a href="#3-1-변수-선언" class="headerlink" title="3.1. 변수 선언"></a>3.1. 변수 선언</h1><h2 id="3-1-1-var-선언자의-특징"><a href="#3-1-1-var-선언자의-특징" class="headerlink" title="3.1.1. var 선언자의 특징"></a>3.1.1. <code>var</code> 선언자의 특징</h2><ul>
<li>호이스팅(hoisting)</li>
<li>함수 레벨 스코프(function level scope) 지원</li>
<li>블록 레벨 스코프(block level scope) 지원하지 않음</li>
</ul>
<h3 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h3><p><code>var</code> 선언자의 첫 번째 특징인 <strong>호이스팅</strong>이란 선언한 변수가 스코프의 최상위로 끌어올림 되는 현상이다. 다음 예시와 같이 <code>hello</code> 변수는 할당을 먼저하고 나중에 선언하지만, 호이스팅으로 인해 에러 없이 <code>world</code>가 출력된다. 그러나 이러한 특징은 가독성을 떨어뜨리기 때문에 지양되는 방법이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello = <span class="string">'world'</span>; <span class="comment">// 할당 후</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello); <span class="comment">// output: world</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello; <span class="comment">// 선언 -&gt; 호이스팅</span></span><br></pre></td></tr></table></figure>

<h3 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h3><p>두 번째 특징인 <strong>함수 레벨 스코프</strong>란 함수 내에서 <strong>선언</strong>한 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 스코프</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'hyeongyu'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_level</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 레벨 스코프</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'thomas'</span>;</span><br><span class="line">&#125;</span><br><span class="line">function_level();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// output: hyeongyu</span></span><br></pre></td></tr></table></figure>

<h3 id="블록-레벨-스코프"><a href="#블록-레벨-스코프" class="headerlink" title="블록 레벨 스코프"></a>블록 레벨 스코프</h3><p><code>var</code> 선언자는 블록 레벨 스코프를 지원하지 않는다. <strong>블록 레벨 스코프</strong>란 블록 <code>{}</code> 내에서만 유효하고 블록 외부에선 참조할 수 없는 것을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 스코프</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'hyeongyu'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 블록 레벨 스코프</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'thomas'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// output: thomas</span></span><br></pre></td></tr></table></figure>

<p>위의 예제처럼 블록 레벨 스코프를 지원하지 않는 경우, 블록 내부의 변수 선언이 외부 변수에 영향을 줄 수 있다.<br>이러한 특징은 사이드 이펙트를 발생시킬 수 있는 여지를 남겨 놓는다. 이러한 특징을 극복하기 위해 나온 것이 <code>let</code>, <code>const</code> 선언입니다.</p>
<h2 id="3-1-2-let-선언자의-특징"><a href="#3-1-2-let-선언자의-특징" class="headerlink" title="3.1.2. let 선언자의 특징"></a>3.1.2. <code>let</code> 선언자의 특징</h2><p><code>var</code>선언의 단점인 호이스팅을 방지하고 블록 레벨 스코프를 지원하기 위해 ES6에서 <code>let</code> 선언자가 등장했다.<br><code>let</code> 선언자는 다음과 같은 특징을 가진다.</p>
<ul>
<li>같은 블록 내 동일 변수명 선언 불가</li>
<li>호이스팅 방지</li>
<li>블록 레벨 스코프 지원</li>
</ul>
<p><code>let</code> 선언자로 선언된 변수는 같은 블록 내에서 같은 이름의 변수를 중복해서 선언할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 스코프</span></span><br><span class="line"><span class="keyword">let</span> name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 함수 레벨 스코프</span></span><br><span class="line">  <span class="keyword">let</span> name; <span class="comment">// OK!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 블록 레벨 스코프</span></span><br><span class="line">  <span class="keyword">let</span> name; <span class="comment">// OK!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// SyntaxError: Identifier 'name' has already been declared</span></span><br></pre></td></tr></table></figure>

<p><code>let</code> 선언은 호이스팅을 방지하기 때문에 아래 예시는 변수 <code>world</code>를 선언하기 전에 변수를 호출하기 때문에 참조 오류가 발생하게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(world); <span class="comment">// ReferenceError: Cannot access 'world' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> world = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure>

<p><code>let</code> 선언자의 세 번째 특징은 블록 레벨 스코프를 지원하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 스코프</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'hyeongyu'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 블록 레벨 스코프</span></span><br><span class="line">  <span class="keyword">let</span> name;</span><br><span class="line">  name = <span class="string">'thomas'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// output: hyeongyu</span></span><br></pre></td></tr></table></figure>

<p>위의 예제는 <code>var</code> 선언의 특징에서도 다룬 것 입니다. <code>var</code> 선언을 사용하였을 경우에는 <code>thomas</code>가 출력되었던 것에 반해 <code>let</code> 선언의 경우에는 <code>hyeongyu</code> 가 출력되었다. 이는 <code>let</code> 선언자가 블록 레벨 스코프를 지원하기 때문이다.</p>
<h2 id="3-1-3-상수-선언"><a href="#3-1-3-상수-선언" class="headerlink" title="3.1.3. 상수 선언"></a>3.1.3. 상수 선언</h2><p><code>const</code> 선언자는 <code>let</code> 선언자와 마찬가지로 호이스팅을 일으키지 않으며 블록 레벨 스코프를 지원하고 있다. <code>let</code> 선언자와 다른 점은 선언할 때 초기화는 가능하지만 재할당되지 않는 읽기 전용(read only) 변수라는 점이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">PI = <span class="number">3.141592</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>위의 변수 <code>PI</code>는 <code>const</code>로 선언한 변수로 재할당할 수 없기 때문에 오류가 발생한다.</p>
<p>그런데 예외적으로 <code>const</code>로 선언한 변수라도 객체 리터럴의 속성으로는 변경할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> profile = &#123;</span><br><span class="line">  firstName: <span class="string">'hyeongyu'</span>,</span><br><span class="line">  lastName: <span class="string">'An'</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">profile.firstName = <span class="string">'thomas'</span>;</span><br><span class="line">profile.age--;</span><br></pre></td></tr></table></figure>

<h1 id="3-2-타입-검사와-타입-선언"><a href="#3-2-타입-검사와-타입-선언" class="headerlink" title="3.2. 타입 검사와 타입 선언"></a>3.2. 타입 검사와 타입 선언</h1><h2 id="3-2-1-점진적-타입-검사"><a href="#3-2-1-점진적-타입-검사" class="headerlink" title="3.2.1. 점진적 타입 검사"></a>3.2.1. 점진적 타입 검사</h2><p>언어에 따라 수행하는 타입 검사의 종류는 크게 ‘정적 타입 검사(statically type checking)’와 ‘동적 타입 검사(dynamically type checking)’로 나뉜다. 자바스크립트는 동적 타입 검사를 수행하는 대표적인 예이다.</p>
<p>반면에 타입스크립트는 점진적인 타입 검사(gradually type checking)를 수행한다. 점진적 타입 검사는 컴파일 시간에 타입 검사를 수행하면서 필요에 따라 타입 선언의 생략을 허용한다. 타입 선언을 생략하면 암시적(implicit) 형변환이 일어난다.</p>
<p>타입스크립트에서 점직적 타이핑(gradual typing)을 설명할 때 적절한 타입으로 <code>any</code>가 있다. <code>any</code> 타입은 모든 타입의 최상위 타입이며, 동적 타입과 정적 타입의 경계선에 있는 타입이다. <code>any</code> 타입으로 선언된 변수는 어떤 타입의 변수도 받아들이면서 심지어 타입 없는 변수도 받아드린다.</p>
<h2 id="3-2-2-자바스크립트의-동적-타이핑"><a href="#3-2-2-자바스크립트의-동적-타이핑" class="headerlink" title="3.2.2. 자바스크립트의 동적 타이핑"></a>3.2.2. 자바스크립트의 동적 타이핑</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">100</span>; <span class="comment">// number 타입</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="string">'hello'</span>; <span class="comment">// string 타입</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="literal">true</span>; <span class="comment">// boolean 타입</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-3-타입-계층도"><a href="#3-2-3-타입-계층도" class="headerlink" title="3.2.3. 타입 계층도"></a>3.2.3. 타입 계층도</h2><p>타입스크립트가 지원하는 점진적 타입 시스템을 더욱 잘 이해하려면 타입 시스템의 계층 구조를 알아둘 필요가 있다.</p>
<p>타입 계층도에서 모든 타입을 받을 수 있는 <code>any</code> 타입이 가장 상위에 있고 그 아래로 다음과 같은 타입이 있다.</p>
<h3 id="기본-Primitive-타입"><a href="#기본-Primitive-타입" class="headerlink" title="기본(Primitive) 타입"></a>기본(Primitive) 타입</h3><p>기본 타입은 보편적으로 가장 많이 사용되는 내장 타입으로서 타입스크립트에서 지원하는 기본 타입의 종류는 다음과 같다.</p>
<ul>
<li>string, number, boolean</li>
<li>symbol(ECMA 2015에 추가됨)</li>
<li>enum</li>
<li>문자열 리터럴</li>
</ul>
<p><code>string</code> 타입은 작은따옴표(‘’)나 큰따옴표(“”)를 사용해 문자열을 변수에 할당할 수 있다. 그런데 타입스크립트 스타일 가이드를 보면 문자열 값은 큰따옴표를 이용할 것을 권장한다. 그리고 역따옴표(``)를 이용한 문자열 또한 <code>string</code> 타입으로 인정된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fullName: string = <span class="string">'hyeongyu An'</span>;</span><br><span class="line"><span class="keyword">let</span> greeting: string = <span class="string">`My name is</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;fullName&#125;</span>.`</span>;</span><br></pre></td></tr></table></figure>

<p><code>number</code> 타입은 ES6 제안으로 10진수뿐만 아니라 16진수, 2진수, 그리고 8진수도 지원한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimal: number = <span class="number">6</span>; <span class="comment">// 10진수</span></span><br><span class="line"><span class="keyword">let</span> hex: number = <span class="number">0xf00d</span>; <span class="comment">// 16진수</span></span><br><span class="line"><span class="keyword">let</span> binary: number = <span class="number">0b1010</span>; <span class="comment">// 2진수</span></span><br><span class="line"><span class="keyword">let</span> octal: number = <span class="number">0o744</span>; <span class="comment">// 8진수</span></span><br></pre></td></tr></table></figure>

<p><code>boolean</code> 타입에는 <code>true</code> 또는 <code>false</code> 값을 할당할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isTrue: boolean = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> isFalse: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><strong>알아보자</strong><br><code>symbol</code>은 Symbol() 함수를 이용해 생성한 고유하고 수정 불가능한 데이터 타입으로 객체 속성의 식별자로 사용된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p><code>enum</code>은 <code>number</code> 타입에서 확장된 것으로 첫 번째 <code>enum</code> 요소에는 숫자 0 값이 할당된다. 그 다음 값은 특별히 초기화 되지 않는 이상 1씩 증가한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum WeekDay &#123; Mon, Tue, Wed, Thu &#125;</span><br><span class="line"><span class="keyword">let</span> day: WeekDay = WeekDay.Wed;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(day);   <span class="comment">// output: 2</span></span><br><span class="line"></span><br><span class="line">enum Month &#123; January = <span class="number">1</span>, February, March, April&#125;</span><br><span class="line"><span class="keyword">let</span> month: Month = Month.March;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;month&#125;</span>월`</span>); <span class="comment">// output: 3월</span></span><br></pre></td></tr></table></figure>

<p>위의 예시 중에서 <code>January = 1</code> 과 같이 <code>enum</code> 요소에 값을 할당하면 그 값으로 바뀌며, 이후 값들은 할당된 값을 기준으로 1씩 증가하게 된다.</p>
<p>문자열 리터럴 타입은 <code>string</code> 타입의 확장 타입으로 사용자 정의 타입에 정의한 문자열만 할당받을 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Tier = <span class="string">'BRONZE'</span> | <span class="string">'SILVER'</span> | <span class="string">'GOLD'</span> | <span class="string">'PLATINUM'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="객체-Object-타입"><a href="#객체-Object-타입" class="headerlink" title="객체(Object) 타입"></a>객체(Object) 타입</h3><p>타입스크립트에서 지원하는 객체 타입의 종류는 다음과 같다.</p>
<ul>
<li>Array</li>
<li>Tuple</li>
<li>Function</li>
<li>생성자</li>
<li>Class</li>
<li>Interface</li>
</ul>
<h2 id="3-2-4-변수에-타입-지정"><a href="#3-2-4-변수에-타입-지정" class="headerlink" title="3.2.4 변수에 타입 지정"></a>3.2.4 변수에 타입 지정</h2><h1 id="3-3-자바스크립트의-타입"><a href="#3-3-자바스크립트의-타입" class="headerlink" title="3.3. 자바스크립트의 타입"></a>3.3. 자바스크립트의 타입</h1><p>자바스크립트에서 지원하는 내장 타입으로는 크게 기본 타입, 객체 타입, 함수 타입이 있다.</p>
<h2 id="3-3-1-자바스크립트의-내장-타입"><a href="#3-3-1-자바스크립트의-내장-타입" class="headerlink" title="3.3.1. 자바스크립트의 내장 타입"></a>3.3.1. 자바스크립트의 내장 타입</h2><table>
<thead>
<tr>
<th>타입명</th>
<th>타입 구분</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>내장 타입</td>
<td><code>true</code>, <code>false</code></td>
</tr>
<tr>
<td>number</td>
<td>내장 타입</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>내장 타입</td>
<td>&#39;&#39;, &quot;&quot;, ``</td>
</tr>
<tr>
<td>symbol(ES6)</td>
<td>내장 타입</td>
<td>symbol 타입</td>
</tr>
</tbody></table>
<p>타입은 대소문자를 구별하기 때문에 사용에 유의해야 한다. 타입스크립트가 기본적으로 제공하고 있는 타입은 모두 소문자이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string: 원시 타입 문자열 타입</span></span><br><span class="line"><span class="keyword">let</span> primitiveStr: string;</span><br><span class="line">primitiveStr = <span class="string">'hello'</span>; <span class="comment">// OK</span></span><br><span class="line">primitiveStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Type 'String' is not assignable to type 'string'.</span></span><br><span class="line"><span class="comment">  'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String: String 생성자 함수로 생성된 String 래퍼 객체 타입</span></span><br><span class="line"><span class="keyword">let</span> objectStr: <span class="built_in">String</span>;</span><br><span class="line">objectStr = <span class="string">'hello'</span>; <span class="comment">// OK</span></span><br><span class="line">objectStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-2-symbol-타입"><a href="#3-3-2-symbol-타입" class="headerlink" title="3.3.2. symbol 타입"></a>3.3.2. symbol 타입</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="built_in">Symbol</span>(<span class="string">"private value"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHome</span>() </span>&#123;</span><br><span class="line">    [count] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add() &#123;</span><br><span class="line">        <span class="keyword">this</span>[count] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-3-enum-타입"><a href="#3-3-3-enum-타입" class="headerlink" title="3.3.3. enum 타입"></a>3.3.3. enum 타입</h2><h1 id="3-4-타입스크립트의-내장-타입"><a href="#3-4-타입스크립트의-내장-타입" class="headerlink" title="3.4. 타입스크립트의 내장 타입"></a>3.4. 타입스크립트의 내장 타입</h1><h2 id="3-4-1-any-타입"><a href="#3-4-1-any-타입" class="headerlink" title="3.4.1. any 타입"></a>3.4.1. any 타입</h2><p><strong>다시보자</strong></p>
<p><code>object</code> 타입과 <code>any</code> 타입의 검사 시점이 다르다!!</p>
<h2 id="3-4-2-배열-타입과-제네릭-배열-타입"><a href="#3-4-2-배열-타입과-제네릭-배열-타입" class="headerlink" title="3.4.2. 배열 타입과 제네릭 배열 타입"></a>3.4.2. 배열 타입과 제네릭 배열 타입</h2><p>배열은 여러 개의 값을 하나의 변수에 담아 관리하는 자료구조이다. 타입스크립트에서 배열 타입은 두 가지로 나뉜다.</p>
<ul>
<li>배열 타입(array type)</li>
<li>제네릭 배열 타입(generic array type)</li>
</ul>
<h3 id="배열-타입"><a href="#배열-타입" class="headerlink" title="배열 타입"></a>배열 타입</h3><p>배열 타입은 타입스크립트 <code>0.9</code> 버전부터 지원됐다.<br>배열 타입은 요소 타입(element type)에 <code>[]</code>를 붙여 선언한다. 요소 타입에는 <code>string</code>, <code>number</code>, <code>boolean</code> 과 같은 내장 타입뿐 아니라 클래스나 인터페이스도 올 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings: string[] = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</span><br></pre></td></tr></table></figure>

<p>배열 요소의 타입이 정해져 있지 않다면 <code>any</code> 타입으로 지정할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anyOne: any[] = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="literal">false</span>];</span><br></pre></td></tr></table></figure>

<p>만약에 배열 요소의 타입이 하나 이상인 경우에는 <em>유니언 타입</em>을 이용해 선언한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiType: (string | number)[] = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isPossibleNull: (string | <span class="literal">null</span>)[] = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="literal">null</span>, <span class="string">'four'</span>];</span><br></pre></td></tr></table></figure>

<h3 id="제네릭-배열-타입"><a href="#제네릭-배열-타입" class="headerlink" title="제네릭 배열 타입"></a>제네릭 배열 타입</h3><p>제네릭 배열 타입 또한 타입스크립트 <code>0.9</code> 버전부터 지원됐다. 제네릭 배열 타입은 <code>Array&lt;T&gt;</code> 형태로 선언한다. 이 때, <code>T</code>는 타입을 의미한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>제네릭 배열 타입 또한 <em>유니언 타입</em>을 이용하면 하나 이상의 타입을 선언해 보다 느슨한 타입 검사를 진행할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiType: <span class="built_in">Array</span>&lt;string | number&gt; = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>타입을 참조할 때는 타입 쿼리(type queries)를 이용한다. 타입 쿼리는 <code>typeof</code> 연산자를 이용해 참조할 변수의 타입을 얻어와 타입을 지정할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiType: <span class="built_in">Array</span>&lt;string | number&gt; = [<span class="number">1</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sameType: <span class="keyword">typeof</span> multiType = [<span class="string">'one'</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'four'</span>];</span><br></pre></td></tr></table></figure>

<p>제네릭 배열 타입은 내장 타입 외에 <strong>객체 타입</strong> 또한 받을 수 있다. 예를 들어, 배열 요소로 익명 함수를 받으려면 아래와 같이 선언하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promises: <span class="built_in">Array</span>&lt;<span class="function"><span class="params">()</span> =&gt;</span> string&gt; = [<span class="keyword">async</span> () =&gt; <span class="string">'one'</span>, <span class="keyword">async</span> () =&gt; <span class="string">'two'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br></pre></td></tr></table></figure>

<p>타입스크립트에서 선언한 배열이 배열 타입이든 제네릭 타입이든 컴파일 시 타입 검사를 위해 필요하고, 컴파일 후(ES5)에는 타입이 제거된 배열만 남는다는 점이다.</p>
<h2 id="3-4-3-튜플-타입"><a href="#3-4-3-튜플-타입" class="headerlink" title="3.4.3. 튜플 타입"></a>3.4.3. 튜플 타입</h2><p>튜플 타입(tuple type)은 n개의 요소로 이뤄진 배열에 대응하는 타입을 의미한다. 튜플은 배열과 비슷한데, 배열은 배열 요소의 개수에 제한이 없고 <code>string[]</code>처럼 특정 타입으로 배열 요소를 강제할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [string, number] = [<span class="string">'one'</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">0</span>].substr(<span class="number">0</span>, <span class="number">2</span>)); <span class="comment">// output: on</span></span><br><span class="line"><span class="built_in">console</span>.log(tuple[<span class="number">0</span>].toFixed(<span class="number">2</span>)); <span class="comment">// Error: Property 'toFixed' does not exist on type 'string'.</span></span><br></pre></td></tr></table></figure>

<p>튜플 타입에서 추가로 알아둘 점은 타입스크립트 2.7 이전에는 배열의 요소가 튜플 타입에 선언된 개수를 초과하면 <strong>유니언 타입</strong>을 적용 받았습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typescript 2.7 이전</span></span><br><span class="line"><span class="comment">// 앞 두 배열 요소 이외에는 &lt;string | number&gt; 타입 적용</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number] = [<span class="string">'tuple'</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="string">'array'</span>];</span><br></pre></td></tr></table></figure>

<p>그런데 타입스크립트 2.7이 되면서 튜플 타입에 따라 할당 배열의 요소 수도 고정되었다.ㄴ</p>
<h2 id="3-4-4-void-null-undefined"><a href="#3-4-4-void-null-undefined" class="headerlink" title="3.4.4. void, null, undefined"></a>3.4.4. void, null, undefined</h2><p><code>void</code>는 함수의 반환값이 없을 때 지정하는 타입이다. <code>void</code> 타입에는 <code>null</code>이나 <code>undefined</code>만 할당할 수 있는데 이는 <code>void</code> 타입이 null과 undefined의 상위 타입이기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>void</code> 타입은 undefined 또는 null만 할당할 수 있으므로 유용한 타입이 아니다.</p>
<p>유의해야할 점은 변수를 선언할 때 값을 할당하지 않았음을 나타내기 위해 선언한 변수에 <code>null</code>을 할당하는 것은 권장하는 방법이 아니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> empty = <span class="literal">null</span>; <span class="comment">// 권장하지 않음</span></span><br></pre></td></tr></table></figure>

<p>null이든 undefined이든 불필요한 선언이 되거나 초기화되지 않았을 때 불안정한 연산을 초래할 수 있으므로 컴파일러 옵션에서 막을 필요가 있다. 이를 위해 <code>tsconfig.json</code>에서 다음과 같이 설정할 수 있다. (기본 값이 <code>true</code>이기 때문에 따로 설정하지 않아도 된다.)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"strickNullChecks"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 <code>null</code>은 값으로 인식되어 object 타입이 되므로 되도록 사용하지 않는 것이 좋으며, <code>undefined</code>를 권장하는 경우 많다.</p>
<p><code>undefined</code>와 <code>null</code>은 구체적인 값이 없다는 점에서 같지만 <code>undefined</code>는 선언은 됐지만 값이 할당되지 않은 것이고 <code>null</code>은 값은 할당됐지만 값이 없는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">// output: false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// output: true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> === <span class="literal">undefined</span>); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>

<p><code>==</code> 연산자는 두 대상의 내용, 즉 값만을 비교하는 것이고 <code>===</code> 연산자는 값뿐만 아니라 타입까지 같은지 확인하는 것이다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/01/06/value_vs_reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/06/value_vs_reference/" class="post-title-link" itemprop="url">Value vs Reference</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-06 21:36:54" itemprop="dateCreated datePublished" datetime="2020-01-06T21:36:54+09:00">2020-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-03 22:52:39" itemprop="dateModified" datetime="2020-04-03T22:52:39+09:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>무심코 사용했던 자바스크립트의 타입들을 정리하고 객체를 보다 정확하게 사용하기 위해 정리했습니다.</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>자바스크립트에는 <strong>value</strong> 를 다루는 5 가지의 데이터 타입이 있다. Boolean, null, undefined, String, 그리고 Number (<strong>Primitives</strong>)</p>
<p>또한 <strong>reference</strong> 를 다루는 3 가지 데이터 타입이 있다. Array, Function, 그리고 Object (<strong>Objects</strong>)</p>
<h2 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h2><p>만약 기본형(primative) 타입이 변수에 할당된다면, 우리는 그 변수가 기본형 값(primitive value)를 포함한다고 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><code>x</code>는 <code>10</code>을 포함하고, <code>y</code>는 <code>&quot;abc&quot;</code>를 포함한다.<br>이 개념을 확실히 하기 위해서, 변수와 할당된 값을 표로 그려보면 아래와 같다.</p>
<p>In memory:</p>
<table>
<thead>
<tr>
<th>Variables</th>
<th>Values</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>10</td>
</tr>
<tr>
<td>y</td>
<td>“abc”</td>
</tr>
<tr>
<td>z</td>
<td>null</td>
</tr>
</tbody></table>
<p>변수의 값을 다른 변수로 <code>=</code>를 사용하여 할당하면, 기존의 값이 복사되어 새로운 변수로 옮겨진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = x;</span><br><span class="line"><span class="keyword">var</span> b = y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y, a, b); <span class="comment">// -&gt; 10, 'abc', 10, 'abc'</span></span><br></pre></td></tr></table></figure>

<p>변수 <code>a</code>와 <code>x</code>는 모두 <code>10</code>을 포함하고 있고, <code>b</code>와 <code>y</code> 또한 <code>&quot;abc&quot;</code> 를 포함하고 있다. 이것들은 각 값을 복사하여 가지고 있기 때문에 분리되어 있다고 할 수 있다.</p>
<p>In memory:</p>
<table>
<thead>
<tr>
<th>Variables</th>
<th>Values</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>10</td>
</tr>
<tr>
<td>y</td>
<td>“abc”</td>
</tr>
<tr>
<td>a</td>
<td>10</td>
</tr>
<tr>
<td>b</td>
<td>“abc”</td>
</tr>
</tbody></table>
<p>그렇기 때문에 변수의 값 변화는 그 값을 복사한 또 다른 변수에게 영향을 끼치지 않는 것이다. 기존의 변수와 값을 복사한 변수는 관계가 없다고 생각하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = x;</span><br><span class="line"><span class="keyword">var</span> b = y;</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">b = <span class="string">'def'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y, a, b); <span class="comment">// -&gt; 10, 'abc', 5, 'def'</span></span><br></pre></td></tr></table></figure>

<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p>기본형 타입이 아닌 값(non-primitive value)이 변수에 할당된다면, 변수는 그 값에 대한 참조(<strong>reference</strong>)를 가지게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">// &lt;- 1</span></span><br><span class="line">arr.push(<span class="number">1</span>); <span class="comment">// &lt;- 2</span></span><br></pre></td></tr></table></figure>

<p>위 두 라인으로 메모리에 적힌 내용을 표로 표현하면,</p>
<p>1.<br>| Variables | Values | Addresses | Objects |<br>| ——— | —— | ——— | ——- |<br>| arr | &lt;#123&gt; | #123 | [] |</p>
<p>2.<br>| Variables | Values | Addresses | Objects |<br>| ——— | —— | ——— | ——- |<br>| arr | &lt;#123&gt; | #123 | [1] |</p>
<h3 id="Assigning-by-Reference"><a href="#Assigning-by-Reference" class="headerlink" title="Assigning by Reference"></a><strong>Assigning by Reference</strong></h3><p>객체(object)와 같은 참조 타입의 값을 <code>=</code>를 사용해 다른 변수에 할당할 경우, 그 값의 주소를 복사하여 포함하게 되는 것이다. 즉, 객체는 값(value)이 아닌 참조(reference)를 복사하여 할당한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> refCopy = reference;</span><br></pre></td></tr></table></figure>

<p>위의 코드을 실행하면 메모리에 아래와 같이 적힌다고 볼 수 있다.</p>
<table>
<thead>
<tr>
<th>Variables</th>
<th>Values</th>
<th>Addresses</th>
<th>Objects</th>
</tr>
</thead>
<tbody><tr>
<td>reference</td>
<td>&lt;#123&gt;</td>
<td>#123</td>
<td>[1]</td>
</tr>
<tr>
<td>refCopy</td>
<td>&lt;#123&gt;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>두 변수는 같은 배열에 대한 참조를 가지고 있다. 이는 둘 중 하나의 변수가 바뀌더라도 두 변수 모두에게 반영된다는 뜻이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reference, refCopy); <span class="comment">// -&gt; [1, 2], [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>In memory:</p>
<table>
<thead>
<tr>
<th>Variables</th>
<th>Values</th>
<th>Addresses</th>
<th>Objects</th>
</tr>
</thead>
<tbody><tr>
<td>reference</td>
<td>&lt;#123&gt;</td>
<td>#123</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>refCopy</td>
<td>&lt;#123&gt;</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Reassigning-a-Reference"><a href="#Reassigning-a-Reference" class="headerlink" title="Reassigning a Reference"></a><strong>Reassigning a Reference</strong></h3><p>동일한 변수에 참조를 재할당할 경우, 재할당된 값이 이전의 참조를 대체하게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">first</span>: <span class="string">'reference'</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>In memory:</p>
<table>
<thead>
<tr>
<th>Variables</th>
<th>Values</th>
<th>Addresses</th>
<th>Objects</th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>&lt;#234&gt;</td>
<td>#234</td>
<td>{first: “reference”}</td>
</tr>
</tbody></table>
<p>두번째 줄을 추가할 경우,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">first</span>: <span class="string">'reference'</span> &#125;;</span><br><span class="line">obj = &#123; <span class="attr">second</span>: <span class="string">'ref2'</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>이전의 객체와 주소값은 여전히 메모리에 남아 있고, 새로운 객체와 주소값이 추가되는 것이다.</p>
<p>In memory:</p>
<table>
<thead>
<tr>
<th>Variables</th>
<th>Values</th>
<th>Addresses</th>
<th>Objects</th>
</tr>
</thead>
<tbody><tr>
<td>obj</td>
<td>&lt;#678&gt;</td>
<td>#234</td>
<td>{first: “reference”}</td>
</tr>
<tr>
<td></td>
<td></td>
<td>#678</td>
<td>{second: “ref2”}</td>
</tr>
</tbody></table>
<p>위의 주소값 <code>&quot;#234&quot;</code>과 같이 객체값에 대한 참조가 없는 경우, 자바스크립트 엔진은 가비지 컬렉션(garbage collection)을 수행한다. 위의 경우, 가비지 컬렉션이 수행되어 객체 <code>{first: &quot;reference&quot;}</code>에는 더 이상 접근할 수 없게 된다.</p>
<h2 id="and"><a href="#and" class="headerlink" title="== and ==="></a>== and ===</h2><p><code>==</code> 와 <code>===</code> 같은 비교 연산자가 참조 타입의 변수에 사용될 경우, 이는 값이 아닌 참조를 비교한다.</p>
<p>같은 객체 대한 참조를 가진 변수들을 비교하면, 결과로 <code>true</code>값을 반환할 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrRef = [<span class="string">'reference'</span>];</span><br><span class="line"><span class="keyword">var</span> arrRef2 = arrRef;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrRef === arrRef2); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>서로 다른 객체인 경우, 동일한 속성(값)을 포함하더라도 비교 결과로 <code>false</code>를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'reference'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'reference'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>만약 당신이 서로 다른 객체가 동일한 속성(값)을 포함하고 있는지 비교하고 싶다면, 가장 쉬운 방법은 객체를 기본형 타입인 <code>String</code>으로 변환한 뒤 그 값들을 비교하면 된다.</p>
<p>비교 연산자는 기본형 타입의 값인 경우에는 단순히 그 값이 일치하는지 여부를 확인한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1Str = <span class="built_in">JSON</span>.stringify(arr1);</span><br><span class="line"><span class="keyword">var</span> arr2Str = <span class="built_in">JSON</span>.stringify(arr2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1Str === arr2Str); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/01/05/memoization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/memoization/" class="post-title-link" itemprop="url">메모이제이션(Memoization)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-05 13:00:00" itemprop="dateCreated datePublished" datetime="2020-01-05T13:00:00+09:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-03 22:15:49" itemprop="dateModified" datetime="2020-04-03T22:15:49+09:00">2020-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redux의 최적화를 위한 라이브러리 Reselect에 적용된 개념이기도 하고, <strong>불필요한 연산을 없앨 수 있다는 점</strong>이 알아두면 언젠가는 사용할 것이라고 생각했습니다.</p>
<h2 id="메모이제이션이란"><a href="#메모이제이션이란" class="headerlink" title="메모이제이션이란"></a>메모이제이션이란</h2><p>메모이제이션은 동일한 계산을 반복해야 할 때, 이전에 <strong>계산한 값을 메모리에 저장</strong>함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술입니다.</p>
<p>즉, 메모는 함수를 위한 캐싱 기법이라고 할 수 있습니다.</p>
<p>메모이제이션은 주어진 입력에 대해 항상 동일한 출력을 반환하는 알고리즘에 한해 사용됩니다. (ex. Fibonacci, Factorial)</p>
<h2 id="피보나치-수열"><a href="#피보나치-수열" class="headerlink" title="피보나치 수열"></a>피보나치 수열</h2><p>피보나치 수열은 대표적인 재귀 함수의 사례입니다.</p>
<p>피보나치 수열의 n번째 값을 구하는 함수는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = <span class="function"><span class="params">n</span> =&gt;</span> (n &lt; <span class="number">2</span> ? n : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>만약 이 함수가 여러 번 실행된다면, 이 함수는 수 없이 호출되어야 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;fibonacci(i)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 직접 호출한 횟수 11 번</span></span><br><span class="line"><span class="comment">// 이미 계산한 값들을 다시 계산하기 위해 호출된 횟수 11 번</span></span><br><span class="line"><span class="comment">// 총 453 번 호출</span></span><br></pre></td></tr></table></figure>

<h2 id="피보나치-수열과-메모이제이션"><a href="#피보나치-수열과-메모이제이션" class="headerlink" title="피보나치 수열과 메모이제이션"></a>피보나치 수열과 메모이제이션</h2><p>만약 메모이제이션을 적용한다면 작업량을 엄청나게 줄일 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> memo = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = memo[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      result = fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>);</span><br><span class="line">      memo[n] = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span>: <span class="subst">$&#123;fibonacci(i)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 직접 호출한 횟수 11 번</span></span><br><span class="line"><span class="comment">// 앞선 메모이제이션 결과를 얻기 위해 호출한 18 번</span></span><br><span class="line"><span class="comment">// 총 29 번 호출</span></span><br></pre></td></tr></table></figure>

<h2 id="메모이제이션-함수의-구현"><a href="#메모이제이션-함수의-구현" class="headerlink" title="메모이제이션 함수의 구현"></a>메모이제이션 함수의 구현</h2><p>재귀함수를 memoize 할 수 있도록 해주는 함수는 만들어보겠습니다.</p>
<h3 id="구현-방법"><a href="#구현-방법" class="headerlink" title="구현 방법"></a>구현 방법</h3><ol>
<li>첫 번째 인자로는 결과를 저장할 배열을 받으며, 두 번째 인자로는 메모이즈할 함수를 받습니다.</li>
<li>반환 값은 함수이며, 구하고자 하는 값이 메모에 없으면 해당 함수를 실행하여 값을 계산한 뒤 메모에 해당 값을 저장합니다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizer = <span class="function">(<span class="params">memo, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> calc = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = memo[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      result = fn(calc, n);</span><br><span class="line">      memo[n] = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> calc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>구현된 함수는 위와 같으며, fibonacci와 factorial을 memoizer 함수를 통해 메모이제이션할 수 있습니다.</p>
<h2 id="피보나치와-팩토리얼의-메모이제이션"><a href="#피보나치와-팩토리얼의-메모이제이션" class="headerlink" title="피보나치와 팩토리얼의 메모이제이션"></a>피보나치와 팩토리얼의 메모이제이션</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoFibonacci = memoizer([<span class="number">0</span>, <span class="number">1</span>], (calc, n) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> calc(n - <span class="number">1</span>) + calc(n - <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> memoFactorial = memoizer([<span class="number">1</span>, <span class="number">1</span>], (calc, n) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> n * calc(n - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="성능-확인"><a href="#성능-확인" class="headerlink" title="성능 확인"></a>성능 확인</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'fibonacci'</span>);</span><br><span class="line">fibonacci(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'fibonacci'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'fibonacci with memo'</span>);</span><br><span class="line">memoFibonacci(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'fibonacci with memo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// fibonacci           : 2.204ms</span></span><br><span class="line"><span class="comment">// fibonacci with memo : 0.086ms</span></span><br></pre></td></tr></table></figure>

<h2 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h2><ol>
<li>메모이즈된 함수는 오래된 결과를 저장하기 때문에 메모리를 <strong>추가적으로 소비</strong>하게 됩니다.</li>
<li>실행 속도가 빠르거나 자주 실행되지 않는 함수의 경우, 실용적이지 않을 수 있습니다.</li>
<li>부작용이 없는 <strong>순수 함수</strong>에만 적용될 수 있습니다.</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Goofy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Goofy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
