<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hyeongyuan.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="모듈 (Module)8.1. 모듈에 대한 이해 8.1.1. 모듈에 대한 이해와 필요성모듈은 독립 가능한 기능의 단입니다. 프로그램은 이러한 모듈들로 구성돼 있고 모듈을 결합하여 하나의 프로그램을 만듭니다. 모듈을 사용하면 다음과 같은 장점이 있습니다.  유지보수의 용이성 전역 스코프 오염을 방지 재사용성 향상  모듈을 사용하면 유지보수가 쉬워집니다. 모듈을">
<meta property="og:type" content="article">
<meta property="og:title" content="타입스크립트 스터디 5주차">
<meta property="og:url" content="https://hyeongyuan.github.io/2020/05/20/typescript-module/index.html">
<meta property="og:site_name" content="DevieW">
<meta property="og:description" content="모듈 (Module)8.1. 모듈에 대한 이해 8.1.1. 모듈에 대한 이해와 필요성모듈은 독립 가능한 기능의 단입니다. 프로그램은 이러한 모듈들로 구성돼 있고 모듈을 결합하여 하나의 프로그램을 만듭니다. 모듈을 사용하면 다음과 같은 장점이 있습니다.  유지보수의 용이성 전역 스코프 오염을 방지 재사용성 향상  모듈을 사용하면 유지보수가 쉬워집니다. 모듈을">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-20T10:30:00.000Z">
<meta property="article:modified_time" content="2020-05-20T12:27:01.704Z">
<meta property="article:author" content="Goofy">
<meta property="article:tag" content="typescript">
<meta property="article:tag" content="module">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hyeongyuan.github.io/2020/05/20/typescript-module/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>타입스크립트 스터디 5주차 | DevieW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DevieW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hyeongyuan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/05/20/typescript-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          타입스크립트 스터디 5주차
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-20 19:30:00 / Modified: 21:27:01" itemprop="dateCreated datePublished" datetime="2020-05-20T19:30:00+09:00">2020-05-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/05/20/typescript-module/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/typescript-module/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="모듈-Module"><a href="#모듈-Module" class="headerlink" title="모듈 (Module)"></a>모듈 (Module)</h1><h2 id="8-1-모듈에-대한-이해"><a href="#8-1-모듈에-대한-이해" class="headerlink" title="8.1. 모듈에 대한 이해"></a>8.1. 모듈에 대한 이해</h2><hr>
<h3 id="8-1-1-모듈에-대한-이해와-필요성"><a href="#8-1-1-모듈에-대한-이해와-필요성" class="headerlink" title="8.1.1. 모듈에 대한 이해와 필요성"></a>8.1.1. 모듈에 대한 이해와 필요성</h3><p>모듈은 독립 가능한 기능의 단입니다. 프로그램은 이러한 모듈들로 구성돼 있고 모듈을 결합하여 하나의 프로그램을 만듭니다. 모듈을 사용하면 다음과 같은 장점이 있습니다.</p>
<ul>
<li>유지보수의 용이성</li>
<li>전역 스코프 오염을 방지</li>
<li>재사용성 향상</li>
</ul>
<p>모듈을 사용하면 유지보수가 쉬워집니다. 모듈을 사용하지 않으면 같은 연산을 수행하는 중복 코드들이 생기고 이는 유지보수를 어렵게 합니다. 자주 사용하는 공통 기능을 모듈로 정의해 사용하면 애플리케이션의 전체적인 수정 없이 모듈의 수정이나 교체만으로도 코드를 효과적으로 수정할 수 있습니다.</p>
<p>또한 모듈은 전역 스코프 오염(global scope pollution)을 방지합니다. 전역 스코프는 전역 이름 공간(global namespace)을 가지므로 번수 이름이나 함수 이름을 중복해 선언할 수 없습니다. 그런데 변수나 함수 등을 파일 내부에 한정해 모듈로 선언하면 이름 공간이 파일 단위로 제한되며 전역 이름 공간을 침범하지 않습니다.</p>
<p>마지막 장점은 모듈을 사용하면 재사용성(reusability)이 향상됩니다. 모듈은 프로젝트에서 자주 사용되는 공통 기능으로 호출될 가능성이 높습니다.</p>
<h3 id="8-1-2-내부-모듈과-외부-모듈"><a href="#8-1-2-내부-모듈과-외부-모듈" class="headerlink" title="8.1.2. 내부 모듈과 외부 모듈"></a>8.1.2. 내부 모듈과 외부 모듈</h3><p>타입스크립트의 모듈을 이해하려면 내부 모듈과 외부 모듈로 구분해야 합니다. 타입스크립트 1.5가 등장하면서 네임스페이스라는 특징과 ES2015 모듈의 특성이 추가됐고 ECMA스크립트 표준 용어집에 따라 모듈이라는 용어가 두 가지로 나뉘게 되었습니다.</p>
<ul>
<li>내부 모듈(internal module)</li>
<li>외부 모듈(external module)</li>
</ul>
<p>내부 모듈은 네임스페이스를 의미하고 외부 모듈은 export라고 선언해 외부로 공개된 모듈을 말합니다.</p>
<h3 id="내부-모듈"><a href="#내부-모듈" class="headerlink" title="내부 모듈"></a>내부 모듈</h3><p>내부 모듈인 네임스페이스는 전역 이름 공간과 분리된 네임스페이스 단위의 이름 공간입니다. 따라서 같은 네임스페이스의 이름 공간이라면 파일 B가 파일 A에 선언된 모듈을 참조(reference)할 수 있는데 참조할 때는 별도의 참주문을 선언하지 않아도 됩니다. 기억할 점은 파일이 다르더라도 같은 프로젝트 내에서 같은 네임스페이스 내에서는 이름을 중복해 클래스, 함수, 변수 등을 선언하면 안 됩니다. 반대로 네임스페이스가 다르면 이름이 같아도 이름 충돌이 없습니다.</p>
<h3 id="외부-모듈"><a href="#외부-모듈" class="headerlink" title="외부 모듈"></a>외부 모듈</h3><p>export로 선언한 모듈을 외부 모듈이라고 합니다. 흔히 말하는 모듈은 외부 모듈을 가리킵니다. 외부 모듈로 선언할 수 있는 대상은 변수, 함수, 클래스 심이어 네임스페이스도 가능합니다. 외부 모듈의 이름 공간은 파일 내로 제한되므로 파일이 다르다면 외부 모듈 이름이 같아도 괜찮습니다. 그런데 export를 생략해 외부 모듈로 선언하지 않으면 전역 스코프의 이름 공간을 공유해 이름 충돌이 발생합니다.</p>
<p>타입스크립트는 모듈 선언과 모듈 호출에 있어 표준인 ES2015 모듈을 지원합니다. 모듈의 선언과 호출을 표준에 맞춰 사용하면 컴파일러가 표준 형식(specification)을 인식할 수 있게 돼 다른 모듈 형식으로 변환할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">tsc --module &lt;모듈 형식&gt; &lt;변환할 파일명&gt;</span><br></pre></td></tr></table></figure>

<p>Module 옵션에서 사용할 수 있는 모듈 형식에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li>commonjs</li>
<li>amd</li>
<li>system</li>
<li>umd</li>
<li>es2015 또는 es6</li>
</ul>
<h2 id="8-2-네임스페이스"><a href="#8-2-네임스페이스" class="headerlink" title="8.2. 네임스페이스"></a>8.2. 네임스페이스</h2><hr>
<h3 id="8-2-1-네임스페이스에-대한-이해"><a href="#8-2-1-네임스페이스에-대한-이해" class="headerlink" title="8.2.1. 네임스페이스에 대한 이해"></a>8.2.1. 네임스페이스에 대한 이해</h3><p>네임스페이스는 하나의 독립된 이름 공간을 만들고 여러 파일에 걸쳐 하나의 이름 공간을 공유할 수 있습니다. 네임스페이스는 <code>namespace</code> 키워드를 이용해 다음과 같이 선언합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Hello &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>네임스페이스와 동일한 역할을 하는 키워드로는 <code>module</code>이 있습니다. namespace와 module은 키워드는 다르지만, 역할과 기능상 차이가 없습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Hello &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>내부 모듈을 선언할 때는 module 대신에 표준인 namespce로 선언해야 합니다.</p>
<h3 id="namespace와-module의-선언과-컴파일-결과-확인"><a href="#namespace와-module의-선언과-컴파일-결과-확인" class="headerlink" title="namespace와 module의 선언과 컴파일 결과 확인"></a>namespace와 module의 선언과 컴파일 결과 확인</h3><p>namespace와 module은 동작과 기능상의 차이가 없고 심지어 컴파일 결과도 차이가 없습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Hello &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 컴파일된 결과</span></span><br><span class="line"><span class="comment">var Hello;</span></span><br><span class="line"><span class="comment">(function (Hello) &#123;</span></span><br><span class="line"><span class="comment">    function print() &#123;</span></span><br><span class="line"><span class="comment">        console.log('Hello!');</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;)(Hello || (Hello = &#123;&#125;));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Hello &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 컴파일된 결과</span></span><br><span class="line"><span class="comment">var Hello;</span></span><br><span class="line"><span class="comment">(function (Hello) &#123;</span></span><br><span class="line"><span class="comment">    function print() &#123;</span></span><br><span class="line"><span class="comment">        console.log('Hello!');</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;)(Hello || (Hello = &#123;&#125;));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>컴파일된 결과를 보면 namespace와 module은 정확히 똑같은 코드로 변환된다는 것을 확인할 수 있습니다. 내부 모듈은 자바스크립트(ES6)로 컴파일될 때 즉시 실행 함수로 변환됩니다.</p>
<p>이처럼 즉시 실행 함수의 내부는 전역 스코프와 분리된 이름 공간입니다. 즉시 실행 함수로 보낼 인수로 <code>Hello || (Hello = {})</code>을 설정했는데 모듈이 있다면 전달하고, 없다면 Hello에 { }으로 초기화해 전달합니다. 이 방법은 모듈 패턴(module pattern)에서 <strong>‘느슨한 확장(loose augmentation)’</strong>으로 불립니다. 반대로 <code>Hello</code>만 을 인수로 전달한다면 비어있지 않고 반드시 초기화된 모듈이 전달되는데, 이 방법은 <strong>‘단단한 확장(tight augmentation)’</strong>이라고 합니다. 즉시 실행 함수에서 Hello 매개변수는 함수 외부에서 함수 내부의 이름 공간에 접근할 수 있게 하는 역할을 합니다.</p>
<h3 id="8-2-2-한-파일에-여러-네임스페이스-선언하기"><a href="#8-2-2-한-파일에-여러-네임스페이스-선언하기" class="headerlink" title="8.2.2. 한 파일에 여러 네임스페이스 선언하기"></a>8.2.2. 한 파일에 여러 네임스페이스 선언하기</h3><p>네임스페이스는 보통 여러 파일에 걸쳐 하나의 이름 공간을 공유하는데 특정 파일에만 네임스페이스를 선언하거나 특정 파일에 여러 네임스페이스를 함께 선언해도 문제가 되지 않습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyInfo1 &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> name1 = <span class="string">'happy1'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyInfo2.name2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyInfo2 &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> name2 = <span class="string">'happy2'</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getName1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyInfo1.name1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(MyInfo1.getName2()); <span class="comment">// happy2</span></span><br><span class="line"><span class="built_in">console</span>.log(MyInfo2.getName1()); <span class="comment">// happy1</span></span><br></pre></td></tr></table></figure>

<p>위 예제에서 MyInfo1과 MyInfo2 네임스페이스는 한 파일에 함께 선언됐습니다. 이때 네임스페이스 간에는 모듈을 서로 호출하고 주고 받을 수 있고, 전역 이름 공간에서 네임스페이스 내부에 선언된 외부 모듈을 호출할 수도 있습니다. 위 코드에서 특이점이 있습니다. MyInfo1 네임스페이스에서 MyInfo2에 선언된 name2 변수 모듈에 접근할 수 있다는 점입니다.</p>
<p>코드가 순차적으로 실행되는 자바스크립트의 특성상 상위에 있는 네임스페이스에서 하위에 선언된 네임스페이스로 접근할 수 없어야 합니다. 그런데 위 코드의 컴파일 결과를 보면 MyInfo1과 MyInfo2 네임스페이스 자바스크립트의 순차적인 실행 특성과 관계없이 자유롭게 호출할 수 있습니다. 이것은 자바스크립트에서 <code>var</code>로 선언된 변수의 호이스팅 특성 때문입니다. 변환 결과(ES6)를 보면 이러한 내용을 확인할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyInfo1;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">MyInfo1</span>) </span>&#123;</span><br><span class="line">  MyInfo1.name1 = <span class="string">'happy1'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyInfo2.name2;</span><br><span class="line">  &#125;</span><br><span class="line">  MyInfo1.getName2 = getName2;</span><br><span class="line">&#125;)(MyInfo1 || (MyInfo1 = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> MyInfo2;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">MyInfo2</span>) </span>&#123;</span><br><span class="line">  MyInfo2.name2 = <span class="string">'happy2'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyInfo1.name1;</span><br><span class="line">  &#125;</span><br><span class="line">  MyInfo2.getName1 = getName1;</span><br><span class="line">&#125;)(MyInfo2 || (MyInfo2 = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>위 예제에서 네임스페이스는 다음 두 변수로 선언됐습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyInfo1;</span><br><span class="line"><span class="keyword">var</span> MyInfo2;</span><br></pre></td></tr></table></figure>

<p>MyInfo1과 MyInfo2는 var 선언자로 선언되어 호이스팅 되므로 실행 순서와 상관없이 즉시 실행 함수 영역 간 호출이 가능합니다. 따라서 즉시 실행 함수인 MyInfo1과 MyInfo2 간에는 변수 MyInfo1과 MyInfo2를 이용해 서로 접근할 수 있습니다.</p>
<h3 id="8-2-3-네임스페이스-하나를-여러-파일에-선언하기"><a href="#8-2-3-네임스페이스-하나를-여러-파일에-선언하기" class="headerlink" title="8.2.3. 네임스페이스 하나를 여러 파일에 선언하기"></a>8.2.3. 네임스페이스 하나를 여러 파일에 선언하기</h3><p>네임스페이스를 이용하면 여러 파일에 걸쳐 하나의 네임스페이스의 이름 공간을 공유할 수 있습니다. 타입스크립트는 네임스페이스를 이용해 논리적 그룹화(logical grouping)를 제공합니다. 논리적 그룹화는 네임스페이스의 이름만 같다면 컴파일 시에 하나의 논리적 영역으로 묶어 컴파일할 수 있게 합니다. 따라서 같은 프로젝트에 속해 있으면서 같은 네임스페이스면 명시적으로 참조하지 않아도 tsc 명령어만으로 타입스크립트 컴파일러가 알아서 네임스페이스 간의 참조 관계를 고려해 컴파일합니다.</p>
<h3 id="참조-경로를-추가하는상황"><a href="#참조-경로를-추가하는상황" class="headerlink" title="참조 경로를 추가하는상황"></a>참조 경로를 추가하는상황</h3><p>tsc 명령어는 프로젝트에 속한 모든 <code>*.ts</code> 파일을 대상으로 프로젝트 단위 컴파일을 수행하므로 네임스페이스를 명시적으로 참조하지 않아도 됩니다. 그런데 프로젝트 단위 컴파일을 수행하지 않고 특정 파일만을 컴파일할 때는 같은 네임스페이스라도 외부에 선언된 네임스페이스를 인식할 수 없습니다.</p>
<p>즉, 프로젝트 단위로 컴파일할 때는 문제가 없지만 외부 참조가 있는 특정 파일만 컴파일할 때는 문제가 됩니다. 이해를 원할하게 하기 위해 먼저 참조할 대상인 <code>car1.ts</code> 파일을 생성하겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Car &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> auto: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> ICar &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    vender: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>car1.ts 파일에는 auto 변수와 ICar 인터페이스가 선언돼 있습니다. 이어서 car1.ts 파일을 참조하는 <code>car2.ts</code> 파일을 작성하겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="car1.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Car &#123;</span><br><span class="line">  <span class="keyword">let</span> wheels: <span class="built_in">number</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(auto);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> Taxi <span class="keyword">implements</span> ICar &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    vender: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Car.auto);</span><br><span class="line"><span class="comment">// console.log(Car.wheels);	&lt;- 접근 불가</span></span><br></pre></td></tr></table></figure>

<p>car2.ts 파일의 Car 네임스페이스에 선언된 Taxi 클래스는 car1.ts 파일에 선언된 ICar 인터페이스를 참조하고 있습니다. 같은 네임스페이스(Car)에 선언돼 있으므로 tsc 명령어를 이용해 프로젝트 단위로 컴파일하면 이상 없이 컴파일됩니다. 그런데 프로젝트 단위 컴파일이 아닌 특정 파일(car2.ts)만을 컴파일하면 문제가 있습니다. 따라서 car2.ts 파일 상단처럼 명시적으로 참조 경로(reference path)를 선언해 줘야 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="car1.ts" /&gt;</span></span><br></pre></td></tr></table></figure>

<p>참조 경로는 트리플 슬래시(triple slash)를 사용해 선언합니다.</p>
<p>car2.ts 파일만 컴파일하면 car2.ts 파일과 참조 경로로 연결된 car1.ts 파일도 함께 컴파일되어 car1.js, car2.js 두 파일이 생성됩니다. 만약 car2.ts 파일만 컴파일 할때 car2.ts 파일에 참조 경로를 삭제하면 다음과 같은 오류가 발생합니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car2.ts:3:15 - error TS2304: Cannot find name <span class="string">'auto'</span>.</span><br><span class="line">car2.ts:5:25 - error TS2304: Cannot find name <span class="string">'ICar'</span>.</span><br><span class="line">car2.ts:10:17 - error TS2339: Property <span class="string">'auto'</span> does not exist on <span class="built_in">type</span> <span class="string">'typeof Car'</span>.</span><br></pre></td></tr></table></figure>

<p>이제 컴파일된 car2.js 파일을 실행해 보겠습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node car2.js</span><br><span class="line"></span><br><span class="line">undefined</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<p>정상적인 값이 출력되는 것이 아니라 <code>undefined</code>가 출력됩니다. 이는 변환된 car2.js 파일에서 car1.js 파일을 참조할 수 없기 때문입니다. 컴파일 후 참조 경로가 주석처럼 인식돼 제 기능을 할 수 없기 때문입니다. car2.ts의 컴파일 결과(ES5)를 통해서 이와 관련된 내용을 확인할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="car1.ts" /&gt;</span></span><br><span class="line"><span class="keyword">var</span> Car;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Car</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wheels;</span><br><span class="line">  <span class="built_in">console</span>.log(Car.auto);</span><br><span class="line">  <span class="keyword">var</span> Taxi = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Taxi</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> Taxi;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)(Car || (Car = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(Car.auto);</span><br><span class="line"><span class="comment">// console.log(Car.wheels);</span></span><br></pre></td></tr></table></figure>

<p>참조 경로로 선언했던 “reference path”는 제 기능을 할 수 없게 주석 처리됐습니다. 더군다나 <code>require</code> 함수도 없어서 외부 모듈 파일을 호출하지 못합니다. 올바른 결과를 확인하려면 두 파일을 합쳐 컴파일해야 합니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --out out.js car2.ts</span><br></pre></td></tr></table></figure>

<p>위 명령어는 car2.ts 파일과 참조하는 car1.ts 파일의 컴파일 결과를 합쳐 out.js 파일을 생성합니다. 컴파일 결과가 한 파일에 존재하므로 참조 경로나 require 함수가 없더라도 결과(ES5)가 정상적으로 출력됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Car;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Car</span>) </span>&#123;</span><br><span class="line">  Car.auto = <span class="literal">false</span>;</span><br><span class="line">&#125;)(Car || (Car = &#123;&#125;));</span><br><span class="line"><span class="comment">/// &lt;reference path="car1.ts" /&gt;</span></span><br><span class="line"><span class="keyword">var</span> Car;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Car</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wheels;</span><br><span class="line">  <span class="built_in">console</span>.log(Car.auto);</span><br><span class="line">  <span class="keyword">var</span> Taxi = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Taxi</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> Taxi;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)(Car || (Car = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(Car.auto);</span><br><span class="line"><span class="comment">// console.log(Car.wheels);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node out.js</span><br><span class="line"></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>만약 컴파일 후에도 결과가 제대로 표시되게 하려면 네임스페이스를 모듈로 선언하고 import 문을 추가해 줘야 합니다.</p>
<h3 id="8-2-4-네임스페이스-모듈"><a href="#8-2-4-네임스페이스-모듈" class="headerlink" title="8.2.4. 네임스페이스 모듈"></a>8.2.4. 네임스페이스 모듈</h3><p>네임스페이스는 export를 이용해 모듈로 선언할 수 있습니다. 모듈로 선언된 네임스페이스는 import 문을 이용해 JS로 컴파일된 뒤에도 명시적으로 모듈 호출(import 문, require 함수 등)을 할 수 있습니다.</p>
<p>위에서 작성했던 car1.ts 파일과 car2.ts 파일의 네임스페이스를 모듈로 선언해보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Car &#123;</span><br><span class="line">  <span class="comment">// export 추가하여 모듈로 선언</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> auto: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> ICar &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    vender: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">'./car1'</span>; <span class="comment">// 네임스페이스 모듈 호출</span></span><br><span class="line"><span class="keyword">namespace</span> Car &#123;</span><br><span class="line">  <span class="keyword">let</span> wheels: <span class="built_in">number</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(ns.Car.auto);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> Taxi <span class="keyword">implements</span> ns.Car.ICar &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    vender: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ns.Car.auto);</span><br></pre></td></tr></table></figure>

<p>위 코드와 같이 구성하면 car2.ts 파일이 car1.ts의 모듈을 명시적으로 호출하게 되고 컴파일 시에도 모듈 호출은 유지됩니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc car2.ts</span><br></pre></td></tr></table></figure>

<p>tsc 컴파일 시 <code>--module</code> 모듈 옵션을 설정하지 않았으므로 tsconfig.json 설정에 별다른 모듈 설정이 없다면 기본으로 <code>CommonJS</code> 모듈 형식으로 변환됩니다. 위 명령어를 입력하면 ES5 표준인 car1.js, car2.js 두 파일이 생성됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">exports.__esModule = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> Car;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Car</span>) </span>&#123;</span><br><span class="line">  Car.auto = <span class="literal">false</span>;</span><br><span class="line">&#125;)((Car = exports.Car || (exports.Car = &#123;&#125;)));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">exports.__esModule = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> ns = <span class="built_in">require</span>(<span class="string">'./car1'</span>);</span><br><span class="line"><span class="keyword">var</span> Car;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Car</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wheels;</span><br><span class="line">  <span class="built_in">console</span>.log(ns.Car.auto);</span><br><span class="line">  <span class="keyword">var</span> Taxi = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Taxi</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> Taxi;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)(Car || (Car = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(ns.Car.auto);</span><br></pre></td></tr></table></figure>

<p>car2.js 파일을 보면 네임스페이스 모듈을 호출하는 부분이 CommonJS 형식에 맞게 require 함수를 사용해 명시적으로 모듈을 호출하고 있음을 확인할 수 있습니다. car2.js 파일을 node 명령어로 실행하면 다음과 같은 정상적인 결과를 얻을 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node car2.js</span><br><span class="line"></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-5-네임스페이스의-이름-확장"><a href="#8-2-5-네임스페이스의-이름-확장" class="headerlink" title="8.2.5. 네임스페이스의 이름 확장"></a>8.2.5. 네임스페이스의 이름 확장</h3><p>네임스페이스의 이름은 알파벳 소문자와 대문자를 사용해 다음처럼 선언합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>네임스페이스 이름은 예외로 점(.)을 허용합니다. 점(.)을 이용하면 네임스페이스 간의 이름 계층을 만드는 효과가 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal.Land &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Animal 네임스페이스와 Animal.Land 네임스페이스는 서로 다른 이름 공간입니다. 이름 공간은 다르지만 논리적인 이름 순서상 상위 이름은 앞에 선언돼야 하고 하위 이름은 상대적으로 뒤에 선언돼야 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal &#123; ... &#125;</span><br><span class="line"><span class="keyword">namespace</span> Animal.Pet &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>한 파일 내에서 여러 네임스페이스가 선언돼 있을 때 네임스페이스의 선언 위치에 상관없이 서로 참조할 수 있기 때문에 순서를 바꿔 선언해도 문제가 되지 않습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal.Land &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'육상 동물이 달립니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">  <span class="comment">// run();	&lt;- 다른 이름 영역이므로 사용할 수  없음</span></span><br><span class="line">  Animal.Land.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [실행 결과]</span></span><br><span class="line"><span class="comment">// 육상 동물이 달립니다.</span></span><br></pre></td></tr></table></figure>

<p>위 코드에서 주목할 점은 위 네임스페이스의 선언 순서는 논리적으로 하위 이름(Animal.Land)이 상위에 위치해 있고 논리적으로 상위 이름(Animal)이 하위에 위치해 있다는 것입니다. 네임스페이스를 선언할 때는 논리적으로 상위 이름에서 하위 이름순으로 배치하는 것이 자연스럽습니다. 이러한 방식으로 네임스페이스를 논리적인 순서로 선언해 보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'동물이 달립니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Animal.Land.run();</span></span><br><span class="line">  <span class="comment">// 하위 네임스페이스 요소는 호출 불가</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animal.Land &#123;</span><br><span class="line">  Animal.run(); <span class="comment">// 상위 네임스페이스 요소 호출</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'육상 동물이 달립니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animal.Land.Pet &#123;</span><br><span class="line">  Animal.Land.run(); <span class="comment">// 상위 네임스페이스 요소 호출</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'애완 동물이 달립니다.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 고양이 클래스</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Cat &#123;</span><br><span class="line">    run() &#123;</span><br><span class="line">      Animal.Land.Pet.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal.Land.Pet.Cat();</span><br><span class="line">cat.run();</span><br><span class="line"><span class="comment">// [실행 결과]</span></span><br><span class="line"><span class="comment">// 동물이 달립니다.</span></span><br><span class="line"><span class="comment">// 육상 동물이 달립니다.</span></span><br><span class="line"><span class="comment">// 애완 동물이 달립니다.</span></span><br></pre></td></tr></table></figure>

<p>위 코드에서 한 단계 나아가 생각해볼 점은 네임스페이스가 위 예제처럼 계층적으로 선언했고 <code>export</code> 키워드를 추가해 모듈로 선언할 때입니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Animal &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Animal.Land &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> Animal.Land.Pet &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 선언된 네임스페이스들을 임포트라혀면 네임스페이스의 최상위 이름만을 이용해야 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Animal &#125; <span class="keyword">from</span> <span class="string">'./namespace-comma'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-6-브라우저에서-네임스페이스의-모듈-호출"><a href="#8-2-6-브라우저에서-네임스페이스의-모듈-호출" class="headerlink" title="8.2.6. 브라우저에서 네임스페이스의 모듈 호출"></a>8.2.6. 브라우저에서 네임스페이스의 모듈 호출</h3><h2 id="8-3-모듈의-이해와-사용"><a href="#8-3-모듈의-이해와-사용" class="headerlink" title="8.3. 모듈의 이해와 사용"></a>8.3. 모듈의 이해와 사용</h2><hr>
<p>타입스크립트는 ES2015 모듈의 선언과 호출과 관련한 스타일을 지원하는데 선언 방법이 꽤 다양합니다. 이번 절에는 모듈을 선언하고 호출하는 여러 방법에 대해 알아 보겠습니다.</p>
<h3 id="8-3-1-모듈-선언과-모듈-임포트"><a href="#8-3-1-모듈-선언과-모듈-임포트" class="headerlink" title="8.3.1. 모듈 선언과 모듈 임포트"></a>8.3.1. 모듈 선언과 모듈 임포트</h3><p>타입스크립트 1.5부터는 ES2015 모듈 시스템을 지원합니다. ES2015 모듈 시스템은 export나 import 제한자를 통해 모듈을 선언하고 호출할 수 있습니다. 모듈은 <code>export</code>로 선언해야 외부로 노출됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Information &#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 export 키워드와 모듈 이름을 함께 선언해 모듈을 노출하는 방식을 <strong>명명된 내보내기(named exports)</strong>라고 합니다. 외부로 노출된 모듈은 <code>import</code> 키워드를 이용해 가져올 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; add, sub &#125; <span class="keyword">from</span> <span class="string">'./calc'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-2-모듈을-개별적으로-노출하고-사용하기"><a href="#8-3-2-모듈을-개별적으로-노출하고-사용하기" class="headerlink" title="8.3.2. 모듈을 개별적으로 노출하고 사용하기"></a>8.3.2. 모듈을 개별적으로 노출하고 사용하기</h3><p>함수나 인터페이스와 같은 단위별로 노출하려면 개별 노출 형식을 사용합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ICard &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">car: ICard, name: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ICard, saveInfo &#125; <span class="keyword">from</span> <span class="string">'./export'</span>;</span><br><span class="line"><span class="keyword">let</span> card: ICard = &#123;&#125;;</span><br><span class="line">saveInfo(card, <span class="string">'happy'</span>);</span><br></pre></td></tr></table></figure>

<p>앞의 두 예제의 export와 import 문은 ES2015 모듈 형식을 사용했으므로 ES6(ES2015)로 컴파일한 결과에서는 export 나 import문은 그대로 유지됩니다. 다른 점은 인터페이스는 컴파일 과정에서 유효한 타입이므로 컴파일 후에는 제거됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">car, name</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; saveInfo &#125; <span class="keyword">from</span> <span class="string">'./export'</span>;</span><br><span class="line"><span class="keyword">let</span> card = &#123;&#125;;</span><br><span class="line">saveInfo(card, <span class="string">'happy'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-3-3-여러-모듈을-함께-export하기"><a href="#8-3-3-여러-모듈을-함께-export하기" class="headerlink" title="8.3.3 여러 모듈을 함께 export하기"></a>8.3.3 여러 모듈을 함께 export하기</h3><p>모듈을 개별적으로 선언해도 되지만 모듈을 선언할 때마다 export 키워드를 붙이건 불편합니다. 이러한 점을 개선하기 위해 여러 모듈을 함께 export해주면 편리합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ver = <span class="string">'1.0'</span>;</span><br><span class="line"><span class="keyword">let</span> author: <span class="built_in">string</span> = <span class="string">'happy'</span>;</span><br><span class="line"><span class="keyword">let</span> extensions = [<span class="string">'jpg'</span>, <span class="string">'bmp'</span>, <span class="string">'png'</span>];</span><br><span class="line"><span class="keyword">let</span> display = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'hello wolrd'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; ver, author, extensions, display &#125;;</span><br></pre></td></tr></table></figure>

<p>다음과 같은 형태로 여러 변수와 함께 외부로 export할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-variables.ts</span></span><br><span class="line"><span class="keyword">export</span> &#123; ver, author, extensions, display &#125;;</span><br></pre></td></tr></table></figure>

<p>export된 변수는 다음과 같이 import해 사용할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ver, author, extensions, display &#125; <span class="keyword">from</span> <span class="string">'./export-variables'</span>;</span><br></pre></td></tr></table></figure>

<p>만약 모듈로 선언할 대상이 인터페이스를 사용하는 함수일 때는 함수가 인터페이스와 의존 관계가 있으므로 함수와 인터페이스를 함께 export해야 합니다. 예를 들어 IProfile이라는 인터페이스가 선언돼 있고 saveProfile이라는 함수가 IProfile 인터페이스를 매개변수의 타입으로 사용하고 있다고 해 보겠습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProfile &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveName</span>(<span class="params">profile: IProfile, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 구현</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; IProfile, saveName <span class="keyword">as</span> save &#125;;</span><br></pre></td></tr></table></figure>

<p>export할 때 모듈의 이름을 변경하려면 <code>as</code> 키워드를 이용합니다.</p>
<h3 id="8-3-4-모듈을-재노출해-사용하기"><a href="#8-3-4-모듈을-재노출해-사용하기" class="headerlink" title="8.3.4. 모듈을 재노출해 사용하기"></a>8.3.4. 모듈을 재노출해 사용하기</h3><h3 id="가져온-모든-모듈을-재노출"><a href="#가져온-모든-모듈을-재노출" class="headerlink" title="가져온 모든 모듈을 재노출"></a>가져온 모든 모듈을 재노출</h3><p>만약 재노출할 모둘이 많아 구체적인 이름을 열거하기가 불편할 때는 “export _ from …” 문법을 이용합니다. 이 문법에서 <code>_</code>은 모든 모듈을 의미합니다. 모듈 파일을 재노출할 때 모든 외부 모듈을 의미하는 *에 대한 별칭이 없으므로 임포트할 때는 as 키워드를 이용해 별칭을 추가해야 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./modules'</span>;</span><br><span class="line">m.setAge(<span class="number">20</span>);</span><br><span class="line">m.setName(<span class="string">'happy'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="네임스페이스로-감싸서-노출하기"><a href="#네임스페이스로-감싸서-노출하기" class="headerlink" title="네임스페이스로 감싸서 노출하기"></a>네임스페이스로 감싸서 노출하기</h3><p>네임스페이스는 독립된 이름 공간이며 export를 이용해 모듈로 선언할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> CarInfo &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>export로 선언하면 다른 파일에서 임포트할 수 있는 모듈이 됩니다. 네임스페이스는 이름 공간을 정의해 하위에 여러 모듈을 포함할 수 있는 특성이 있습니다. 이 때문에 네임스페이스를 기존에 흩어졌던 모듈을 다시 용도에 맞게 감싸서 재노출할 용도로 사용할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-car.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyCar &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; Engine <span class="keyword">as</span> SuperEngine &#125; <span class="keyword">from</span> <span class="string">'./engine'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// engine.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Engine &#123;</span><br><span class="line">  construtor(<span class="keyword">public</span> name: <span class="built_in">string</span>) &#123;&#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>네임스페이스는 외부에 노출할 모듈을 모아 라이브러리 형태로 정의할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// car-info.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; MyCar <span class="keyword">as</span> SuperCar, SuperEngine &#125; <span class="keyword">from</span> <span class="string">'./my-car'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> CarInfo &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> car = SuperCar;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> engine = SuperEngine;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제에서 여러 하위 모듈을 재구성하기 위해 CarInfo 네임스페이스를 정의했습니다. 네임스페이스는 복잡한 하위 모듈 구성을 하나의 이름 영역 안에 재구성해 주는 역할을 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CarInfo &#125; <span class="keyword">from</span> <span class="string">'./car-info-module'</span>;</span><br><span class="line"></span><br><span class="line">CarInfo.Hello();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> CarInfo.car(<span class="string">'My Car'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> engine = <span class="keyword">new</span> CarInfo.engine(<span class="string">'My Engine'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(engine.name);</span><br><span class="line"><span class="comment">// [실행 결과]</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// My Car</span></span><br><span class="line"><span class="comment">// My Engine</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-5-디폴트-모듈의-이해와-사용법"><a href="#8-3-5-디폴트-모듈의-이해와-사용법" class="headerlink" title="8.3.5. 디폴트 모듈의 이해와 사용법"></a>8.3.5. 디폴트 모듈의 이해와 사용법</h3><h3 id="export-equals-문과-import-equals-문"><a href="#export-equals-문과-import-equals-문" class="headerlink" title="export-equals 문과 import-equals 문"></a>export-equals 문과 import-equals 문</h3><p>타입스크립트 1.5가 발표되기 전에는 모듈을 선언할 때 export-equals 문으로 할당(assignment)했고, 모듈을 호출할 때는 import-equals 문으로 임포트했습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> = validator;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Validator = <span class="built_in">require</span>(<span class="string">'validator'</span>);</span><br></pre></td></tr></table></figure>

<p>import-equals 문이나 export-equals 문은 CommonJS와 AMD 스타일 모듈과 호환이 가능합니다.</p>
<h3 id="디폴트-모듈-선언"><a href="#디폴트-모듈-선언" class="headerlink" title="디폴트 모듈 선언"></a>디폴트 모듈 선언</h3><p>타입스크립트 1.5에서는 import-equals 문과 export-equals 문 대신 다른 형태로 모듈을 선언하거나 임포트할 수 있습니다. 먼저 export-equals 할당은 <code>default</code> 키워드를 이용한 방식으로 바꼈습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  title: <span class="string">'hello world'</span>,</span><br><span class="line">  length: <span class="number">11</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>위와 같이 default로 선언된 모듈은 <strong>파일마다 하나씩만 선언</strong>돼야 합니다. 위 선언은 여러 형태의 변형이 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  title: <span class="string">'hello world'</span>,</span><br><span class="line">  length: <span class="number">11</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 함수</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기명 함수</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Hello &#123;</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>import-equals 문은 require( )를 쓰는 대신에 ES6의 <code>import</code> 형식으로 가져올 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Validator <span class="keyword">from</span> <span class="string">'./validator'</span>;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 작성할 수도 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> Validator &#125; <span class="keyword">from</span> <span class="string">'./validator'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="디폴트-모듈과-명명된-모듈을-함께-가져오기"><a href="#디폴트-모듈과-명명된-모듈을-함께-가져오기" class="headerlink" title="디폴트 모듈과 명명된 모듈을 함께 가져오기"></a>디폴트 모듈과 명명된 모듈을 함께 가져오기</h3><p>디폴트 모듈(default module)은 default 키워드를 사용해서 선언합니다. 디폴트 모듈의 특성은 모듈 파일에 최대 1개까지만 선언할 수 있다는 것입니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default.ts</span></span><br><span class="line"><span class="keyword">const</span> p = &#123;</span><br><span class="line">  name: <span class="string">'happy'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> h: <span class="built_in">string</span> = <span class="string">'hell ts!'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; p <span class="keyword">as</span> <span class="keyword">default</span>, h <span class="keyword">as</span> hello &#125;;</span><br></pre></td></tr></table></figure>

<p>위 예제와 같이 export하는 디폴드 모듈 p와 다른 모듈을 함께 export할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; p <span class="keyword">as</span> <span class="keyword">default</span>, h <span class="keyword">as</span> <span class="keyword">default</span> &#125;; <span class="comment">// Error: Duplicate identifier 'default'</span></span><br></pre></td></tr></table></figure>

<p>유의할 점은 디폴트 모듈의 경우에는 일반 모듈과는 달리 { }에 선언하면 안 되고 { }가 없이 선언해야 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> p, &#123; hello &#125; <span class="keyword">from</span> <span class="string">'./default'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello, p);</span><br><span class="line"><span class="comment">// [실행 결과]</span></span><br><span class="line"><span class="comment">// hello ts! &#123; name: 'happy', age: 30 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="디폴트-모듈로-타입과-모듈을-함께-노출"><a href="#디폴트-모듈로-타입과-모듈을-함께-노출" class="headerlink" title="디폴트 모듈로 타입과 모듈을 함께 노출"></a>디폴트 모듈로 타입과 모듈을 함께 노출</h3><p>디폴트 모듈로 사용할 HelloMessage 함수의 반환 타입으로 Message가 선언돼 있다고 해봅시다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">Message</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 선언되면 어쩔 수 없이 HelloMessage와 Message를 동시에 노출할 수 밖에 없습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; HelloMessage <span class="keyword">as</span> <span class="keyword">default</span>, Message &#125;;</span><br></pre></td></tr></table></figure>

<p>만약 HelloMessage만을 export하되 타입을 함께 노출하려면 어떻게 해야 할까요? 방법은 디폴트 모듈로 export할 함수명과 인터페이스 타입명을 일치시키 선언하면 됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export.ts</span></span><br><span class="line"><span class="keyword">interface</span> HelloMessage &#123;</span><br><span class="line">  first: <span class="built_in">string</span>;</span><br><span class="line">  second: stirng;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">HelloMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> message: HelloMessage = &#123; first: <span class="string">'hello'</span>, second: name &#125;;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HelloMessage;</span><br></pre></td></tr></table></figure>

<p>위와 같이 export된 디폴트 모듈을 임포트하면 같은 이름을 이용해 함수 또는 인터페이스 타입으로 사용할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./export'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> helloMessage: hello = hello(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hello(<span class="string">'hello'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(helloMessage);</span><br><span class="line"><span class="comment">// [실행 결과]</span></span><br><span class="line"><span class="comment">// &#123; first: 'hello', second: 'hello' &#125;</span></span><br><span class="line"><span class="comment">// &#123; first: 'hello', second: 'hello' &#125;</span></span><br></pre></td></tr></table></figure>

<p>임포트한 hello 디폴트 모듈은 <code>hello(&quot;hello&quot;)</code>와 같은 함수로 사용될 수 있고 <code>helloMessage: hello</code>와 같이 타입으로 사용될 수 있습니다. 이런 것이 가능한 이유는 타입스크립트 컴파일러가 hello가 선언된 위치에 따라 함수인지 타입인지 구분해 타입 검사를 하기 때문입니다.</p>
<h2 id="8-4-모듈-시스템"><a href="#8-4-모듈-시스템" class="headerlink" title="8.4. 모듈 시스템"></a>8.4. 모듈 시스템</h2><hr>
<h3 id="8-4-1-모듈-로더와-모듈-형식"><a href="#8-4-1-모듈-로더와-모듈-형식" class="headerlink" title="8.4.1. 모듈 로더와 모듈 형식"></a>8.4.1. 모듈 로더와 모듈 형식</h3><p>모둘 로더(module loader)는 모듈 파일에 선언된 모듈을 실행할 수 있습니다. 브라우저에서 동작하는 모듈 로더는 느린 로딩(lazy loading)의 방식으로 모듈 파일을 가져와 모듈을 실행합니다.</p>
<p>타입스크립트에서는 모듈을 정의하거나 호출할 때 ES2015 모듈을 이용합니다. 타입스크립트는 자바스크립트로 컴파일돼 실행됩니다. 이때 ES2015 모듈이 표준이지만 더 많은 브라우저에서 지원하게 하고자 ES5 표준으로 컴파일하고 ES2015 모듈은 모듈 로더를 통해 호출할 수 있습니다.</p>
<p>모듈 형식(module format)은 모듈 정의에 관한 표준 명세(specification)에 해당합니다. 모듈 로더가 특정 모듈 형식을 지원하려면 모듈 로더가 지원하는 모듈 형식에 맞춰 컴파일해야 합니다.</p>
<p>최근에 나온 모듈 로더는 대체로 CommonJS와 AMD 모듈 형식을 기본으로 지원합니다. 타입스크립트 컴파일러는 특정 모듈 형식으로 컴파일하도록 여러 모듈 형식을 지원합니다.</p>
<ul>
<li>commonjs</li>
<li>amd</li>
<li>system</li>
<li>umd</li>
<li>es2015 (import/exports로 사용 형식이 같음)</li>
</ul>
<p>이들 중 타입스크립트는 ES2015 모듈 형식을 기본으로 사용합니다.</p>
<h3 id="8-4-2-모듈-형식에-맞춰-컴파일하기"><a href="#8-4-2-모듈-형식에-맞춰-컴파일하기" class="headerlink" title="8.4.2. 모듈 형식에 맞춰 컴파일하기"></a>8.4.2. 모듈 형식에 맞춰 컴파일하기</h3><h3 id="모듈-형식에-따른-컴파일-방법"><a href="#모듈-형식에-따른-컴파일-방법" class="headerlink" title="모듈 형식에 따른 컴파일 방법"></a>모듈 형식에 따른 컴파일 방법</h3><p>프로젝트 기반으로 target을 ES5로 지정해 컴파일하려면,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc -t es5 -m &lt;모듈 형식&gt;</span><br></pre></td></tr></table></figure>

<p>특정 모듈 파일만을 컴파일하려면,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc --module &lt;모듈 형식&gt; &lt;변환할 모듈 파일 이름&gt;</span><br></pre></td></tr></table></figure>

<p>이렇게 <code>--module</code> 옵션에 사용할 수 있는 모듈 형식의 설정값은 다음과 같습니다.</p>
<ul>
<li>none</li>
<li>commjs</li>
<li>amd</li>
<li>system</li>
<li>um</li>
<li>es6 또는 es2015</li>
</ul>
<p>설정값 중에 <code>none</code>은 ES2015 모듈 형식과 CommonJS 모듈 형식을 사용하지 않을 때 설정합니다.</p>
<p>만약 –module 옵션 사용 시 모듈 형식을 지정하지 않으면 target 값에 따라 다르게 기본값이 정해집니다. 예를 들어 target 옵션을 “–target es2015”와 같이 설정했다면 –module 옵션은 <strong>ES2015 모듈 형식을 기본</strong>으로 두지만 그렇지 않으면 <strong>CommonJS 모듈 형식을 기본값</strong>으로 둡니다.</p>
<h3 id="–module-옵션에-대한-부가적인-설명"><a href="#–module-옵션에-대한-부가적인-설명" class="headerlink" title="–module 옵션에 대한 부가적인 설명"></a>–module 옵션에 대한 부가적인 설명</h3><p>명령어로 컴파일할 때 <code>--out</code> 옵션을 사용하면 입력 파일을 받아 단일 파일로 생성할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">$ tsc --out &lt;출력할 js파일명&gt; &lt;변환할 ts파일명&gt; --module &lt;모듈 형식&gt;</span><br></pre></td></tr></table></figure>

<p>–out 옵션과 –module 옵션을 사용할 때 허용하는 설정값은 amd, system 두 가지뿐입니다. –out 옵션은 단일 파일로 컴파일해 결과를 생성해 내는 옵션이므로 단일 파일에 적합하지 않은 나머지 모듈 형식은 허용되지 않습니다.</p>
<p>만약 소스 맵이 필요하다면 <code>-sourcemap</code> 옵션을 추가합니다.</p>
<h2 id="8-5-각종-모듈-형식에-대한-소개"><a href="#8-5-각종-모듈-형식에-대한-소개" class="headerlink" title="8.5. 각종 모듈 형식에 대한 소개"></a>8.5. 각종 모듈 형식에 대한 소개</h2><hr>
<h3 id="8-5-1-ES2015"><a href="#8-5-1-ES2015" class="headerlink" title="8.5.1. ES2015"></a>8.5.1. ES2015</h3><p>타입스크립트는 ES2015 모듈 형식을 기본으로 채택해 모듈을 선언하고 모듈을 호출합니다.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/typescript/" rel="tag"># typescript</a>
              <a href="/tags/module/" rel="tag"># module</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/28/typescript-interface/" rel="prev" title="타입스크립트 스터디 4주차">
      <i class="fa fa-chevron-left"></i> 타입스크립트 스터디 4주차
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/20/typescript-advanced-type/" rel="next" title="타입스크립트 스터디 6주차">
      타입스크립트 스터디 6주차 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#모듈-Module"><span class="nav-number">1.</span> <span class="nav-text">모듈 (Module)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-모듈에-대한-이해"><span class="nav-number">1.1.</span> <span class="nav-text">8.1. 모듈에 대한 이해</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-모듈에-대한-이해와-필요성"><span class="nav-number">1.1.1.</span> <span class="nav-text">8.1.1. 모듈에 대한 이해와 필요성</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-내부-모듈과-외부-모듈"><span class="nav-number">1.1.2.</span> <span class="nav-text">8.1.2. 내부 모듈과 외부 모듈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#내부-모듈"><span class="nav-number">1.1.3.</span> <span class="nav-text">내부 모듈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#외부-모듈"><span class="nav-number">1.1.4.</span> <span class="nav-text">외부 모듈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-네임스페이스"><span class="nav-number">1.2.</span> <span class="nav-text">8.2. 네임스페이스</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-네임스페이스에-대한-이해"><span class="nav-number">1.2.1.</span> <span class="nav-text">8.2.1. 네임스페이스에 대한 이해</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace와-module의-선언과-컴파일-결과-확인"><span class="nav-number">1.2.2.</span> <span class="nav-text">namespace와 module의 선언과 컴파일 결과 확인</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-한-파일에-여러-네임스페이스-선언하기"><span class="nav-number">1.2.3.</span> <span class="nav-text">8.2.2. 한 파일에 여러 네임스페이스 선언하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-네임스페이스-하나를-여러-파일에-선언하기"><span class="nav-number">1.2.4.</span> <span class="nav-text">8.2.3. 네임스페이스 하나를 여러 파일에 선언하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#참조-경로를-추가하는상황"><span class="nav-number">1.2.5.</span> <span class="nav-text">참조 경로를 추가하는상황</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4-네임스페이스-모듈"><span class="nav-number">1.2.6.</span> <span class="nav-text">8.2.4. 네임스페이스 모듈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-5-네임스페이스의-이름-확장"><span class="nav-number">1.2.7.</span> <span class="nav-text">8.2.5. 네임스페이스의 이름 확장</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-6-브라우저에서-네임스페이스의-모듈-호출"><span class="nav-number">1.2.8.</span> <span class="nav-text">8.2.6. 브라우저에서 네임스페이스의 모듈 호출</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-모듈의-이해와-사용"><span class="nav-number">1.3.</span> <span class="nav-text">8.3. 모듈의 이해와 사용</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-모듈-선언과-모듈-임포트"><span class="nav-number">1.3.1.</span> <span class="nav-text">8.3.1. 모듈 선언과 모듈 임포트</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-모듈을-개별적으로-노출하고-사용하기"><span class="nav-number">1.3.2.</span> <span class="nav-text">8.3.2. 모듈을 개별적으로 노출하고 사용하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-여러-모듈을-함께-export하기"><span class="nav-number">1.3.3.</span> <span class="nav-text">8.3.3 여러 모듈을 함께 export하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-4-모듈을-재노출해-사용하기"><span class="nav-number">1.3.4.</span> <span class="nav-text">8.3.4. 모듈을 재노출해 사용하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#가져온-모든-모듈을-재노출"><span class="nav-number">1.3.5.</span> <span class="nav-text">가져온 모든 모듈을 재노출</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#네임스페이스로-감싸서-노출하기"><span class="nav-number">1.3.6.</span> <span class="nav-text">네임스페이스로 감싸서 노출하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-5-디폴트-모듈의-이해와-사용법"><span class="nav-number">1.3.7.</span> <span class="nav-text">8.3.5. 디폴트 모듈의 이해와 사용법</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#export-equals-문과-import-equals-문"><span class="nav-number">1.3.8.</span> <span class="nav-text">export-equals 문과 import-equals 문</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#디폴트-모듈-선언"><span class="nav-number">1.3.9.</span> <span class="nav-text">디폴트 모듈 선언</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#디폴트-모듈과-명명된-모듈을-함께-가져오기"><span class="nav-number">1.3.10.</span> <span class="nav-text">디폴트 모듈과 명명된 모듈을 함께 가져오기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#디폴트-모듈로-타입과-모듈을-함께-노출"><span class="nav-number">1.3.11.</span> <span class="nav-text">디폴트 모듈로 타입과 모듈을 함께 노출</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-모듈-시스템"><span class="nav-number">1.4.</span> <span class="nav-text">8.4. 모듈 시스템</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-모듈-로더와-모듈-형식"><span class="nav-number">1.4.1.</span> <span class="nav-text">8.4.1. 모듈 로더와 모듈 형식</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-2-모듈-형식에-맞춰-컴파일하기"><span class="nav-number">1.4.2.</span> <span class="nav-text">8.4.2. 모듈 형식에 맞춰 컴파일하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#모듈-형식에-따른-컴파일-방법"><span class="nav-number">1.4.3.</span> <span class="nav-text">모듈 형식에 따른 컴파일 방법</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#–module-옵션에-대한-부가적인-설명"><span class="nav-number">1.4.4.</span> <span class="nav-text">–module 옵션에 대한 부가적인 설명</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-각종-모듈-형식에-대한-소개"><span class="nav-number">1.5.</span> <span class="nav-text">8.5. 각종 모듈 형식에 대한 소개</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-1-ES2015"><span class="nav-number">1.5.1.</span> <span class="nav-text">8.5.1. ES2015</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Goofy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Goofy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-hyeongyuan-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://hyeongyuan.github.io/2020/05/20/typescript-module/";
    this.page.identifier = "2020/05/20/typescript-module/";
    this.page.title = "타입스크립트 스터디 5주차";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://https-hyeongyuan-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
