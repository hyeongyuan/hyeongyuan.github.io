<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hyeongyuan.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="제한동시성 코드를 작성할 때, 안전한 작동을 위한 몇 가지 옵션이 있다.  메모리 공유를 위한 동기화 기본 요소(예: sync.Mutex) 통신을 위한 동기화(예: 채널)  (위 두 가지 옵션은 앞 장에서 이미 다루었습니다.)  변경 불가능한 데이터 제한에 의해 보호되는 데이터  (이번 장에서는 나머지 두 가지 옵션을 살펴보겠습니다.) 변경 불가능한 데이터">
<meta property="og:type" content="article">
<meta property="og:title" content="Go의 동시성 패턴">
<meta property="og:url" content="https://hyeongyuan.github.io/2020/04/14/golang_pattern_1/index.html">
<meta property="og:site_name" content="DevieW">
<meta property="og:description" content="제한동시성 코드를 작성할 때, 안전한 작동을 위한 몇 가지 옵션이 있다.  메모리 공유를 위한 동기화 기본 요소(예: sync.Mutex) 통신을 위한 동기화(예: 채널)  (위 두 가지 옵션은 앞 장에서 이미 다루었습니다.)  변경 불가능한 데이터 제한에 의해 보호되는 데이터  (이번 장에서는 나머지 두 가지 옵션을 살펴보겠습니다.) 변경 불가능한 데이터">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-14T04:00:00.000Z">
<meta property="article:modified_time" content="2020-07-23T07:39:56.549Z">
<meta property="article:author" content="Goofy">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="goroutine">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hyeongyuan.github.io/2020/04/14/golang_pattern_1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Go의 동시성 패턴 | DevieW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DevieW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hyeongyuan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/04/14/golang_pattern_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go의 동시성 패턴
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-14 13:00:00" itemprop="dateCreated datePublished" datetime="2020-04-14T13:00:00+09:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-23 16:39:56" itemprop="dateModified" datetime="2020-07-23T16:39:56+09:00">2020-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/04/14/golang_pattern_1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/14/golang_pattern_1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="제한"><a href="#제한" class="headerlink" title="제한"></a>제한</h1><p>동시성 코드를 작성할 때, 안전한 작동을 위한 몇 가지 옵션이 있다.</p>
<ul>
<li>메모리 공유를 위한 동기화 기본 요소(예: sync.Mutex)</li>
<li>통신을 위한 동기화(예: 채널)</li>
</ul>
<p>(위 두 가지 옵션은 앞 장에서 이미 다루었습니다.)</p>
<ul>
<li>변경 불가능한 데이터</li>
<li>제한에 의해 보호되는 데이터</li>
</ul>
<p>(이번 장에서는 나머지 두 가지 옵션을 살펴보겠습니다.)</p>
<p>변경 불가능한 데이터는 암시적으로 동시에 실행해도 안전하기 때문에 이상적이다. 동시에 실행되는 각 프로세스는 동일한 데이터에서 동작할 수 있지만 이를 수정할 수는 없다.</p>
<ul>
<li>개발자의 인지 부하 감소</li>
<li>임계 영역의 크기 감소</li>
</ul>
<blockquote>
<p><strong>임계 구역</strong>(critical section) 또는 <strong>공유변수 영역</strong>은 병렬컴퓨팅에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다.</p>
<p>출처: <a href="https://ko.wikipedia.org/wiki/임계_구역" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/임계_구역</a></p>
</blockquote>
<p>제한은 애드 혹(ad hoc)과 어휘적(lexical)이라는 두 가지 방식으로 가능합니다.</p>
<blockquote>
<p><strong>애드혹</strong>(라틴어: Ad hoc)은 “이것을 위해” 즉 “특별한 목적을 위해서”라는 뜻의 라틴어로, 일반적으로 다음을 나타낸다.</p>
<ol>
<li>특정한 문제나 일을 위해 만들어진 관습적인 해결책</li>
<li>일반화할 수 없는 해결책</li>
<li>어떤 다른 목적에서 적응시킬 수 없는 해결책</li>
</ol>
<p>출처: <a href="https://ko.wikipedia.org/wiki/애드혹" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/애드혹</a></p>
</blockquote>
<p>애드 혹 제한이란, 언어의 커뮤니티나 근무하는 그룹 또는 작업하는 코드베이스에서 설정된 관례에 의해 제한이 이루어진 경우입니다.</p>
<p>(다음의 예제를 살펴봅시다.)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">loopData := <span class="function"><span class="keyword">func</span><span class="params">(handleData <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(handleData)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;</span><br><span class="line">		handleData &lt;- data[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleData := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> loopData(handleData)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> handleData &#123;</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(정수 데이터 슬라이스는 handleData 채널을 통해 loopData 함수와 루프 모두에서 사용할 수 있지만, 관례적으로 loopData 함수에서만 접근합니다. 그러나 많은 사람이 코드를 건드리는 경우도 있고, 실수가 일어나 제한이 깨지면서 문제가 발생할 수 있습니다.)</p>
<p>어휘적 제한은 올바른 데이터만 노출하기 위한 어휘 범위 및 이를 사용하는 여러 동시 프로세스를 위한 동시성 기본 요소와 관련이 있다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">chanOwner := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)	<span class="comment">// --------------------- (1)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">			results &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer := <span class="function"><span class="keyword">func</span><span class="params">(results &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;		<span class="comment">// ----------- (2)</span></span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Received: %d\n"</span>, result)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Done receiving!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">results := chanOwner()	<span class="comment">// ----------------------------- (3)</span></span><br><span class="line">consumer(results)</span><br></pre></td></tr></table></figure>



<p>(1) chanOwner의 어휘 범위 내부에서 채널을 인스턴스화한다. 이는 results 채널의 쓰기 측면의 범위를 그 아래에 정의된 클로저로 제한한다.</p>
<p>(2) 채널의 읽기 측면을 받아 consumer 내부로 전달해 consumer가 읽기 외에는 다른 작업을 하지 못하도록 할 수 있다.</p>
<p>(3) int 채널의 읽기 전용 복사본을 받는다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">printData := <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup, data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buff bytes.Buffer</span><br><span class="line">	<span class="keyword">for</span> _, b := <span class="keyword">range</span> data &#123;</span><br><span class="line">		fmt.Fprintf(&amp;buff, <span class="string">"%c"</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(buff.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"golang"</span>)</span><br><span class="line"><span class="keyword">go</span> printData(&amp;wg, data[:<span class="number">3</span>])	<span class="comment">// -------------------- (1)</span></span><br><span class="line"><span class="keyword">go</span> printData(&amp;wg, data[<span class="number">3</span>:])	<span class="comment">// -------------------- (2)</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>



<h2 id="동기화를-사용할-수-있다면-왜-제한을-추구해야-하는가"><a href="#동기화를-사용할-수-있다면-왜-제한을-추구해야-하는가" class="headerlink" title="동기화를 사용할 수 있다면 왜 제한을 추구해야 하는가?"></a>동기화를 사용할 수 있다면 왜 제한을 추구해야 하는가?</h2><p>그 이유는 성능을 향상시키고 개발자의 인지 부하를 줄이기 위해서다.</p>
<p>(동기화는 비용이 들며, 이를 피할 수 있으면 임계 영역이 없기 때문에 동기화 비용을 지불할 필요가 없습니다. 또한 동기화로 인해 발생 가능한 모든 문제도 막을 수 있습니다.)</p>
<p>또한 어휘적 제한을 사용하는 동시성 코드는 이를 사용하지 않는 동시성 코드보다 더 이해하기 쉽다는 이점이 있다.</p>
<p>그럼에도 제한을 설정하는 것은 어려울 수 있으며, 때로는 멋진 Go 동시성 기본 요소로 돌아가야 한다.</p>
<h1 id="for-select-루프"><a href="#for-select-루프" class="headerlink" title="for-select 루프"></a>for-select 루프</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;	<span class="comment">// 무한 반복 또는 특정 범위에 대한 루프</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 채널에 대한 작업</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for-select</code> 루프가 나타날 수 있는 몇 가지 시나리오를 살펴보자.</p>
<h2 id="채널에서-반복-변수-보내기"><a href="#채널에서-반복-변수-보내기" class="headerlink" title="채널에서 반복 변수 보내기"></a>채널에서 반복 변수 보내기</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">case</span> stringStream &lt;- s:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="멈추기를-기다리면서-무한히-대기"><a href="#멈추기를-기다리면서-무한히-대기" class="headerlink" title="멈추기를 기다리면서 무한히 대기"></a>멈추기를 기다리면서 무한히 대기</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 첫 번째</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  &#125;	</span><br><span class="line">  <span class="comment">// 선점 불가능한(non-preemptable) 작업 수행</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 선점 불가능한 작업 수행</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(select 구문을 들어갔을 때 done 채널이 닫히지 않았다면, default 구문을 대신 실행할 것입니다.)</p>
<h1 id="고루틴-누수-방지"><a href="#고루틴-누수-방지" class="headerlink" title="고루틴 누수 방지"></a>고루틴 누수 방지</h1><p>런타임은 고루틴을 임의의 수의 운영체제 스레드로 다중화하며, 많은 경우에 해당 추상화 수준에 대한 염려할 필요가 없도록 처리합니다. 그러나 고루틴들은 자원을 필요로 하며, 런타임에 의해 가비시 컬렉션되지 않으므로, 그들이 남기는 메모리 흔적이 얼마나 작든 그 흔적들을 남겨두고 싶지 않습니다.</p>
<p>고루틴이 종료되는 데는 몇 가지 경로가 있습니다.</p>
<ul>
<li>작업이 완료됐을 때</li>
<li>복구할 수 없는 에러로 인해 더 이상 작업을 계속할 수 없을 때</li>
<li>작업을 중단하라는 요청을 받았을 때</li>
</ul>
<p>처음 두 경로는 사용자의 알고리즘이므로 별다른 노력 없이 도달할 수 있습니다. 그러나 작업 취소는 어떻게 해야 할까요?</p>
<p>고루틴은 일련의 조직화된 방식으로 다른 몇몇 고루틴들과 협력할 가능성이 큽니다. 자식 고루틴이 계속 실행돼야 하는지 여부는 많은 다른 고루틴들의 상태에 대한 지식에 근거해 정할 수 있습니다. 이러한 전체 문맥에 대한 지식을 가진 부모 고루틴(많은 경우 main 고루틴)은 그 자식 고루틴에게 종료하라고 말할 수 있어야 합니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(strings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	completed := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"doWork exited."</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(completed)</span><br><span class="line">		<span class="keyword">for</span> s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">			<span class="comment">// 원하는 작업을 수행</span></span><br><span class="line">			fmt.Println(s)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> completed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doWork(<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 여기서 추가적인 작업이 이루어질 수 있다.</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Done."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// completed := doWork(nil)</span></span><br><span class="line"><span class="comment">// &lt;- completed</span></span><br><span class="line"><span class="comment">// [ 출력 ]</span></span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>

<p>(nil 채널을 doWork로 전달하여 strings 채널은 실제로 어떠한 문자열도 쓰지 않으며, doWork를 포함하는 고루틴은 이 프로세스가 지속되는 동안 메모리에 남아 있게 됩니다. 이 예제에서는 프로세스의 수명이 매우 짧지만, 실제 프로그램에선 고루틴을 계속 돌려 메모리 사용량에 영향을 미칠 것입니다.)</p>
<p>심지어 doWork 및 main 고루틴 내에서 고루틴을 조인(join)하면 데드락 상태가 발생합니다.</p>
<p>이를 성공적으로 완화하는 방법은, 부모 고루틴이 자식 고루틴에게 취소(cancellation) 신호를 보낼 수 있도록 부모와 자식 고루틴들 사이에 신호를 설정하는 것입니다. 일반적으로 이 신호는 <code>done</code>이라는 읽기 전용 채널입니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">doWork := <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	strings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;	<span class="comment">// -------------------- (1)</span></span><br><span class="line">	terminated := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"doWork exited."</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(terminated)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> s := &lt;-strings:</span><br><span class="line">				<span class="comment">// 원하는 작업을 수행</span></span><br><span class="line">				fmt.Println(s)</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:	<span class="comment">// ------------------------ (2)</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> terminated</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">terminated := doWork(done, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">// -------------------------------- (3)</span></span><br><span class="line">	<span class="comment">// 1초 후에 작업을 취소한다.</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"Canceling doWork goroutine..."</span>)</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-terminated	<span class="comment">// ------------------------------ (4)</span></span><br><span class="line">fmt.Println(<span class="string">"Done."</span>)</span><br></pre></td></tr></table></figure>

<p>(1) 일반적으로 취소 신호를 위한 done 채널은 첫 번째 매개 변수로 전달한다.</p>
<p>(2) for-select 패턴을 사용하고 있는데 case 구문 중 하나는 done 채널이 신호를 받았는지 여부를 확인하는 것이다.</p>
<p>(3) 1초 이상 지나면 doWork에 생성된 고루틴을 취소할 또 다른 고루틴을 생성한다.</p>
<p>(4) doWork에서 생성된 고루틴과 main 고루틴을 조인한다.</p>
<p>(위 예제와는 달리 strings 채널에 nil을 전달했음에도 불구하고, 고루틴이 성공적으로 종료됐습니다. 또한 두 개의 고루틴을 조인하지만 데드락 상태가 발생하지 않습니다. <strong>그 이유는 두 개의 고루틴을 조인하기 전에, 세 번째 고루틴을 생성해 1초 후에 doWork 내에서 고루틴을 취소하기 때문입니다.</strong>)</p>
<p>채널에 값을 쓰려는 시도를 차단하는 고루틴의 경우</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"newRandStream closure exited."</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			randStream &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">randStream := newRandStream()</span><br><span class="line">fmt.Println(<span class="string">"3 random int:"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%d: %d\n"</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>출력 결과부터 지연된(defer) fmt.Println 구문이 절대 실행되지 않는다는 것을 알 수 있습니다.</p>
<p>루프의 세 번째 반복 이후에, 고루틴 블록은 더 이상 읽을 수 없는 채널에 다음번 랜덤 정수를 보내려고 시도합니다. 예제에서는 생산자에게 멈춰도 된다고 말할 방법이 없습니다. 해결책은 생산자 고루틴에게 종료를 알리는 채널을 제공하는 것입니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"newRandStream closure exited."</span>)</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(randStream)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> randStream &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> randStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">randStream := newRandStream(done)</span><br><span class="line">fmt.Println(<span class="string">"3 random int:"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%d: %d\n"</span>, i, &lt;-randStream)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 진행 중인 작업을 시뮬레이션한다.</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br></pre></td></tr></table></figure>


<h2 id="“다른-고루틴을-생성한-책임이-있는-고루틴은-해당-고루틴을-중지시킬-책임도-진다-”"><a href="#“다른-고루틴을-생성한-책임이-있는-고루틴은-해당-고루틴을-중지시킬-책임도-진다-”" class="headerlink" title="“다른 고루틴을 생성한 책임이 있는 고루틴은 해당 고루틴을 중지시킬 책임도 진다.”"></a>“다른 고루틴을 생성한 책임이 있는 고루틴은 해당 고루틴을 중지시킬 책임도 진다.”</h2><p>고루틴의 중지를 보장하는 방법은 고루틴의 타입과 목적에 따라 다를 수 있지만, 모두 done 채널을 전달하는 것을 바탕으로 구축됩니다.</p>
<h1 id="or-채널"><a href="#or-채널" class="headerlink" title="or 채널"></a>or 채널</h1><p>때로는 하나 이상의 done 채널을 하나의 done 채널로 걸합해, 그 구성 요소 중 하나의 채널이 닫힐 때 결합된 채널이 닫히도록 해야 할 경우도 있을 것입니다. 이 경우에는 이러한 결합을 수행하는 select문을 작성하는 것이 좋습니다.</p>
<p>재귀 및 고루틴들을 이용해 복합 done 채널을 만듭니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> or <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">or = <span class="function"><span class="keyword">func</span><span class="params">(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;	<span class="comment">// -- (1)</span></span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:	<span class="comment">// -------------------------------------------------------- (2)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:	<span class="comment">// -------------------------------------------------------- (3)</span></span><br><span class="line">		<span class="keyword">return</span> channels[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;	<span class="comment">// ---------------------------------------------------- (4)</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:	<span class="comment">// ------------------------------------------------------ (5)</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:	<span class="comment">// ---------------------------------------------------- (6)</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">0</span>]:</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">case</span> &lt;-channels[<span class="number">2</span>]:</span><br><span class="line">			<span class="keyword">case</span> &lt;-or(<span class="built_in">append</span>(channels[<span class="number">3</span>:], orDone)...):	<span class="comment">// ---------------- (6)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> orDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 가변(variadic) 채널 슬라이스를 받아 하나의 채널을 반환하는 or 함수가 있습니다.</p>
<p>(2) 이 함수는 재귀 함수이므로 종료 기준을 설정해야 합니다. 그 중 첫 번째 종료 기준은 가번 슬라이스가 비어 있으면 단순히 nil 채널을 반환한다는 것입니다.</p>
<p>(3) 두 번째 기준은 가변 슬라이스에 하나의 요소만 있으면 해당 요소를 반환하는 것입니다.</p>
<p>(4) 재귀가 발생하는 부분으로 채널들에서 차단 없이 메세지를 기다릴 수 있도록 고루틴을 생성합니다.</p>
<p>(5) 재귀 방식을 사용하고 있기 때문에, or에 대한 모든 재귀 호출은 적어도 두 개의 채널을 가지고 있습니다.</p>
<p>(6) </p>
<p>이는 여러 개의 채널을 한 개의 채널로 결합해, 여러 채널 중에 하나라도 닫히거나 채널에 데이터가 쓰여지면 모든 채널이 닫히도록 할 수 있는 매우 간결한(?) 함수입니다. 다음은 설정된 지속 시간 후에 닫히는 여러 채널들을 받아서, 이들을 or 함수를 사용해 단일 채널로 결합하고 이를 닫는 간단한 예제입니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sig := <span class="function"><span class="keyword">func</span><span class="params">(after time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">		time.Sleep(after)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">start := time.Now()</span><br><span class="line">&lt;-or(</span><br><span class="line">	sig(<span class="number">2</span>*time.Hour),</span><br><span class="line">	sig(<span class="number">5</span>*time.Minute),</span><br><span class="line">	sig(<span class="number">1</span>*time.Second),</span><br><span class="line">	sig(<span class="number">1</span>*time.Hour),</span><br><span class="line">	sig(<span class="number">1</span>*time.Minute),</span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">"done after %v"</span>, time.Since(start))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 출력 ]</span></span><br><span class="line"><span class="comment">// done after 1.000375051s</span></span><br></pre></td></tr></table></figure>

<p>호출이 닫히기까지 서로 다른 시간이 소요되는 여러 개의 채널을 배치함에도 불구하고, 1초 후에 닫히는 채널로 인해 or 호출에 의해 생성된 전체 채널이 닫힌다는 점에 주목해야 합니다.</p>
<p>추가적인 고루틴들의 비용인 f(x) = [x/2]의 비용으로 이 간결함을 얻을 수 있습니다.(여기서 x는 고루틴의 수입니다.) Go의 강점 중 하나는 고루틴을 신속하게 생성하고 스케줄링 및 실행할 수 있다는 것입니다.</p>
<p>이 패턴은 시스템의 모듈들이 교차하는 지점에서 사용할 때 유용합니다. 이러한 교차점에서는 콜 스텍을 통해 고루틴 트리를 취소할 수 있는 여러 개의 조건이 존재하곤 합니다. or 함수를 사용해 간단히 이 조건들을 결합하고 스택 아래쪽으로 전달할 수 있습니다.</p>
<h1 id="에러-처리"><a href="#에러-처리" class="headerlink" title="에러 처리"></a>에러 처리</h1><p>동시성 프로그램에서 에러 처리를 올바르게 진행하는 일은 어려울 수 도 있습니다. Go는 널리 알려진 에러의 예외  모델을 피하면서 에러 처리가 중요하다는 사실을 알렸습니다. 동시에 실행되는 여러 개의 프로세스로 작업할 때 어떤 식으로 에러를 처리해야 하는지 살펴보겠습니다.</p>
<p>에러 처리에 관한 생각을 할 때 가장 근본적인 질문은 <strong>“에러 처리의 책임자는 누구인가?”</strong>입니다. 어떤 시점에서는 스택에 따라 에러를 전달하는 것을 멈추고 실제로 뭔가를 수행해야 합니다. 누가 이를 책임지겠습니까?</p>
<p>동시에 실행되는 프로세스들은 부모 또는 형제 프로세스와 독립적으로 작동하기 때문에 에러와 관련해 제대로 된 일이 무엇인지 추론하기 어려울 수 있습니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	urls ...<span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> &lt;-<span class="title">chan</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">	responses := <span class="built_in">make</span>(<span class="keyword">chan</span> *http.Response)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(responses)</span><br><span class="line">		<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">			resp, err := http.Get(url)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)	<span class="comment">// -------------------------- (1)</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> responses &lt;- resp:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> responses</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"https://google.com"</span>, <span class="string">"https://badhost"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> response := <span class="keyword">range</span> checkStatus(done, urls...) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Response: %v\n"</span>, response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 고루틴은 에러를 출력할 뿐 다른 행동을 취할 선택지가 없습니다. 에러를 출력하고 누군가 주목해주기를 바랄 뿐입니다.</p>
<p>고루틴들을 이러한 어색한 상황에 빠뜨리지 않아야 합니다. <strong>관심 사항을 분리할 것을 권합니다.</strong> 일반적으로 동시에 실행되는 프로세스들은 프로그램의 상태에 대해 완전한 정보를 가지고 있는 프로그램의 다른 부분으로 에러를 보내야 하며, 그래야 보다 많은 정보를 바탕으로 무엇을 해야 할지 결정할 수 있습니다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;	<span class="comment">// ------------------------------------------- (1)</span></span><br><span class="line">	Error    error</span><br><span class="line">	Response *http.Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">	urls ...<span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> &lt;-<span class="title">chan</span> <span class="title">Result</span></span> &#123;	<span class="comment">// ----------------------------------------------- (2)</span></span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(results)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">			<span class="keyword">var</span> result Result</span><br><span class="line">			resp, err := http.Get(url)</span><br><span class="line">			result = Result&#123;Error: err, Response: resp&#125;	<span class="comment">// --------------- (3)</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> results &lt;- result:	<span class="comment">// ----------------------------------- (4)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"https://google.com"</span>, <span class="string">"https://badhost"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> checkStatus(done, urls...) &#123;</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;	<span class="comment">// -------------------------------------- (5)</span></span><br><span class="line">		fmt.Printf(<span class="string">"error: %v\n"</span>, result.Error)</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"Response: %v\n"</span>, result.Response.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [출력]</span></span><br><span class="line"><span class="comment">// Response: 200 OK</span></span><br><span class="line"><span class="comment">// error: Get "https://badhost": dial tcp: lookup badhost: no such host</span></span><br></pre></td></tr></table></figure>

<p>(1) *http.Response와 고루틴 내의 루프 반복 시에 발생할 수 있는 error 모두를 포함하는 타입을 생성합니다.</p>
<p>(2) 루프 반복의 결과를 읽어올 수 있는 채널을 반환합니다.</p>
<p>(3) Error 및 Response 필드가 설정된 인스턴스를 만듭니다.</p>
<p>(4) 채널에 Resut를 씁니다.</p>
<p>(5) 고루틴 내에서 발생한 에러를 더 큰 프로그램의 전체 컨텍스트 내에서 처리할 수 있습니다.</p>
<p>여기서서는 잠재적인 출력을 잠재적인 에러와 연결한 방법이 핵심입니다. 이는 checkStatus 고루틴에서 생성 가능한 결과의 전체 집합을 나타내며, 에러가 발생했을 때 main 고루틴이 수행할 작업을 결정할 수 있게 해줍니다. 넓은 의미에서 에러 처리의 문제를 생산자 고루틴과 성공적으로 분리했다는 것입니다.</p>
<p>단순한 에러를 출력하는 것 말고도, 다른 작업을 할 수도 있습니다. 세 가지 이상의 에러가 발생하면 상태를 확인하는 것을 멈추게 해봅시다.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">errCount := <span class="number">0</span></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"https://google.com"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> checkStatus(done, urls...) &#123;</span><br><span class="line">	<span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"error: %v\n"</span>, result.Error)</span><br><span class="line">		errCount++</span><br><span class="line">		<span class="keyword">if</span> errCount &gt;= <span class="number">3</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Too many errors, breaking!"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"Response: %v\n"</span>, result.Response.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [출력]</span></span><br><span class="line"><span class="comment">// error: Get "a": unsupported protocol scheme ""</span></span><br><span class="line"><span class="comment">// Response: 200 OK</span></span><br><span class="line"><span class="comment">// error: Get "b": unsupported protocol scheme ""</span></span><br><span class="line"><span class="comment">// error: Get "c": unsupported protocol scheme ""</span></span><br><span class="line"><span class="comment">// Too many errors, breaking!</span></span><br></pre></td></tr></table></figure>

<p>여기서 주목할 점은 고루틴들에서 반환될 값을 구성할 때 에러가 <strong>일급 객체</strong>로 간주돼야 한다는 것입니다. 고루틴이 에러를 발생시킬 수 있는 경우, 이러한 에러는 결과 타입과 밀접하게 결합돼야 하며, 일반적인 동기 함수처럼 동일한 통신 회선을 통해 전달돼야 합니다.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
              <a href="/tags/goroutine/" rel="tag"># goroutine</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/14/mysql-uninstall/" rel="prev" title="Mac 유저를 위한 MySQL 설치 및 삭제">
      <i class="fa fa-chevron-left"></i> Mac 유저를 위한 MySQL 설치 및 삭제
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/14/mac-key-tip/" rel="next" title="맥 유저를 위한 작은 팁">
      맥 유저를 위한 작은 팁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#제한"><span class="nav-number">1.</span> <span class="nav-text">제한</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#동기화를-사용할-수-있다면-왜-제한을-추구해야-하는가"><span class="nav-number">1.1.</span> <span class="nav-text">동기화를 사용할 수 있다면 왜 제한을 추구해야 하는가?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for-select-루프"><span class="nav-number">2.</span> <span class="nav-text">for-select 루프</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#채널에서-반복-변수-보내기"><span class="nav-number">2.1.</span> <span class="nav-text">채널에서 반복 변수 보내기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#멈추기를-기다리면서-무한히-대기"><span class="nav-number">2.2.</span> <span class="nav-text">멈추기를 기다리면서 무한히 대기</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#고루틴-누수-방지"><span class="nav-number">3.</span> <span class="nav-text">고루틴 누수 방지</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#“다른-고루틴을-생성한-책임이-있는-고루틴은-해당-고루틴을-중지시킬-책임도-진다-”"><span class="nav-number">3.1.</span> <span class="nav-text">“다른 고루틴을 생성한 책임이 있는 고루틴은 해당 고루틴을 중지시킬 책임도 진다.”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#or-채널"><span class="nav-number">4.</span> <span class="nav-text">or 채널</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#에러-처리"><span class="nav-number">5.</span> <span class="nav-text">에러 처리</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Goofy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Goofy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-hyeongyuan-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://hyeongyuan.github.io/2020/04/14/golang_pattern_1/";
    this.page.identifier = "2020/04/14/golang_pattern_1/";
    this.page.title = "Go의 동시성 패턴";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://https-hyeongyuan-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
