<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hyeongyuan.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="타입 선언과 변경, 타입 호환타입 선언과 변경 타입 에일리어스타입 에일리어스를 이용한 단일 타입 선언타입 에일리어스(type alias)는 타입스크립트 1.4 버전부터 지원된 특징입니다. 타입 에일리어스를 이용하면 기존 타입에 새로운 이름을 지을 수 있습니다. 12[형식]type &lt;바인딩 식별자&gt; &#x3D; 타입;  바인딩 식별자(binding">
<meta property="og:type" content="article">
<meta property="og:title" content="타입스크립트 스터디 7주차">
<meta property="og:url" content="https://hyeongyuan.github.io/2020/06/03/typescript-type-assertion/index.html">
<meta property="og:site_name" content="DevieW">
<meta property="og:description" content="타입 선언과 변경, 타입 호환타입 선언과 변경 타입 에일리어스타입 에일리어스를 이용한 단일 타입 선언타입 에일리어스(type alias)는 타입스크립트 1.4 버전부터 지원된 특징입니다. 타입 에일리어스를 이용하면 기존 타입에 새로운 이름을 지을 수 있습니다. 12[형식]type &lt;바인딩 식별자&gt; &#x3D; 타입;  바인딩 식별자(binding">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-03T11:30:00.000Z">
<meta property="article:modified_time" content="2020-06-03T10:51:58.547Z">
<meta property="article:author" content="Goofy">
<meta property="article:tag" content="typescript">
<meta property="article:tag" content="type-assertion">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hyeongyuan.github.io/2020/06/03/typescript-type-assertion/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>타입스크립트 스터디 7주차 | DevieW</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DevieW</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hyeongyuan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hyeongyuan.github.io/2020/06/03/typescript-type-assertion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Goofy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevieW">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          타입스크립트 스터디 7주차
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-03 20:30:00 / Modified: 19:51:58" itemprop="dateCreated datePublished" datetime="2020-06-03T20:30:00+09:00">2020-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index"><span itemprop="name">typescript</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/06/03/typescript-type-assertion/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/03/typescript-type-assertion/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="타입-선언과-변경-타입-호환"><a href="#타입-선언과-변경-타입-호환" class="headerlink" title="타입 선언과 변경, 타입 호환"></a>타입 선언과 변경, 타입 호환</h1><h2 id="타입-선언과-변경"><a href="#타입-선언과-변경" class="headerlink" title="타입 선언과 변경"></a>타입 선언과 변경</h2><hr>
<h2 id="타입-에일리어스"><a href="#타입-에일리어스" class="headerlink" title="타입 에일리어스"></a>타입 에일리어스</h2><h3 id="타입-에일리어스를-이용한-단일-타입-선언"><a href="#타입-에일리어스를-이용한-단일-타입-선언" class="headerlink" title="타입 에일리어스를 이용한 단일 타입 선언"></a>타입 에일리어스를 이용한 단일 타입 선언</h3><p>타입 에일리어스(type alias)는 타입스크립트 1.4 버전부터 지원된 특징입니다. 타입 에일리어스를 이용하면 기존 타입에 새로운 이름을 지을 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[형식]</span><br><span class="line">type &lt;바인딩 식별자&gt; &#x3D; 타입;</span><br></pre></td></tr></table></figure>

<p>바인딩 식별자(binding identifier)는 타입의 별칭(alias)에 해당하는 타입 에일리어스입니다. 새롭게 정의할 수 있는 타입은 string, number, boolean 등과 같은 단일 타입 외에도 유니언이나 객체 리터럴처럼 다소 복잡한 타입도 가능합니다. 이처럼 타입에 새로운 별칭을 만드는 과정을 줄여서 <strong>에일리어싱(aliasing)</strong>이라 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> usernameType = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> ageType = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> locationType = <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>에일리어싱을 할 때 고려할 점은 에일리어싱할 타입이 단일 타입인 경우 타입 별칭이 많아질 뿐 특별한 이점을 얻을 수 없습니다.</p>
<h3 id="타입-에일리어스를-이용한-유니언-타입-선언"><a href="#타입-에일리어스를-이용한-유니언-타입-선언" class="headerlink" title="타입 에일리어스를 이용한 유니언 타입 선언"></a>타입 에일리어스를 이용한 유니언 타입 선언</h3><p>타입 에일리어스는 단일 타입보다는 유니언 타입이나 리터럴 타입과 같은 다소 복잡한 형태의 타입에 적용하면 좋습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> idType = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> profileType = <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  id: idType;</span><br><span class="line">  profile?: profileType;</span><br><span class="line">  username: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1: User = &#123; id: <span class="string">'1'</span>, username: <span class="string">'hyeongyu'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> user2: User = &#123; id: <span class="string">'2'</span>, profile: <span class="literal">undefined</span>, username: <span class="string">'thomas'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> user3: User = &#123; id: <span class="string">'3'</span>, profile: <span class="string">'./avatar.png'</span>, username: <span class="string">'koon'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> user1, user1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> user2, user2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> user3, user3);</span><br></pre></td></tr></table></figure>

<h3 id="타입-에일리어스를-이용한-배열-타입-선언"><a href="#타입-에일리어스를-이용한-배열-타입-선언" class="headerlink" title="타입 에일리어스를 이용한 배열 타입 선언"></a>타입 에일리어스를 이용한 배열 타입 선언</h3><p>배열은 하나의 변수에 여러 값을 관리할 수 있는 효율적인 자료형입니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArrayType = <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arraySample: ArrayType = [<span class="number">1</span>, <span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arraySample.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arraySample[<span class="number">0</span>], <span class="keyword">typeof</span> arraySample[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p><code>Array&lt;number | boolean&gt;</code>과 같이 유니언 타입으로 배열 타입을 선언하면 문자열 “1”이나 문자열 “true”가 입력되는 문제를 방지할 수 있습니다.</p>
<h2 id="타입-추론"><a href="#타입-추론" class="headerlink" title="타입 추론"></a>타입 추론</h2><p>타입스크립트에서는 값을 할당할 때 타입을 명시하지 않으면 타입 추론(type inference)을 통해 타입이 결정됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="string">'c'</span>, <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> values);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> values[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> values[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> values[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>values는 object 타입이며, 내부 요소는 타입이 다르더라도 서로 간에 할당할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values[<span class="number">0</span>] = values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>그런데 변수의 경우 각 변수에 처음 값이 할당되는 시점에 타입이 정해지므로 초기화가 이뤄진 다음에는 다른 타입의 값을 할당할 수 있습니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="string">'2'</span>;</span><br><span class="line"><span class="comment">// first = second; &lt;- Error</span></span><br></pre></td></tr></table></figure>

<p>first 변수의 타입은 <code>number</code> 타입으로 결정됐기 때문에 <code>string</code> 타입으로 결정된 변수 second는 first에 할당할 수 없습니다.</p>
<h2 id="타입-캐스팅-변환-어설션"><a href="#타입-캐스팅-변환-어설션" class="headerlink" title="타입 캐스팅, 변환, 어설션"></a>타입 캐스팅, 변환, 어설션</h2><h3 id="타입-캐스팅과-변환"><a href="#타입-캐스팅과-변환" class="headerlink" title="타입 캐스팅과 변환"></a>타입 캐스팅과 변환</h3><p><strong>타입 캐스팅(type casting)</strong>은 명시적으로 선언한 캐스팅 코드에 의한 타입 변경을 의미하며, JS 인터프리터에 의해 타입이 바뀌는 타입 변환(type conversion)과 구분됩니다. 타입 캐스팅의 예로, null이나 undefined를 제외한 인수 값은 기본 래퍼 객체를 이용해 캐스팅할 수 있습니다. 기본 래퍼 객체를 함수 호출 방식으로 사용하며 다음과 같은 종류가 있습니다.</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>
<p>타입을 변경할 때 기본 래퍼 객체 외에도 <code>+</code> 연산자를 이용할 수 있는데, 이는 Number 함수를 호출하는 방법과 같습니다. 그리고 <code>parseInt</code>를 이용해 숫자가 포함된 문자열을 숫자 타입으로 변경할 수 있습니다. 다만, parseInt 함수가 Number 함수와 다른 점이 있다면 parseInt는 함수 이름처럼 파싱 기능이 있어 숫자 외에 여러 문자가 섞여 있을 때 숫자만을 골라서 숫자 타입으로 변경할 수 있다는 점입니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'50px'</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1010'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'50px'</span>);</span><br></pre></td></tr></table></figure>

<p>parseInt 함수는 입력값으로 입력값으로 “50px”와 같이 숫자에 여러 문자가 섞여 있어도 숫자만 선택해 50을 반환합니다. 반면, Number 함수는 문자와 숫자가 섞여 있다면 <code>NaN</code>을 반환합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = +myNum;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>(myNum);</span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(myNum);</span><br></pre></td></tr></table></figure>

<p><code>+</code> 연산자의 경우 문자열이 들어오면 number 타입으로 변환하고, 숫자라면 숫자를 할당하고, 숫자가 아니면 NaN(Not a Number) 값이 됩니다. 변수 myNum에 “a”를 할당했다면, 숫자가 포함되어 있지 않으므로 위 세 가지 방법으로 타입 변환했을 때 모두 NaN 값이 되므로 NaN 값인지 검사하는 로직을 추가해야 합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(num1)) &#123;</span><br><span class="line">  <span class="comment">// num1이 NaN이므로 적절한 로직 추가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>지금까지 살펴본 parseInt, Number와 같은 타입 변환 함수들은 런타임 때 사용되므로 컴파일 후에도 유지됩니다.</p>
<h3 id="타입-어설션"><a href="#타입-어설션" class="headerlink" title="타입 어설션"></a>타입 어설션</h3><p><strong>타입 어설션(type assertion)</strong>을 이용하면 타입스크립트가 타입 어설션 정보를 이용해 컴파일을 수행합니다. 따라서 타입 어설션은 컴파일 과정까지만 유효하고 컴파일 후에는 사라집니다. 타입 어설션의 방식은 크게 꺾쇠 괄호(angle bracket) 방식과 as 문법(as syntax)을 이용한 방식이 있습니다.</p>
<p>타입 어설션은 타입스크립트에서 유효하지만 ES6로 컴파일하면 타입 어설션이 제거됩니다.</p>
<p>타입 어설션에 사용되는 꺾쇠 기호가 포함된 `<number>의 선언 형태는 리액트(React)에서 사용되는 JSX 문법과 유사해 충돌을 일으킵니다. 이러한 단점을 보완하기 위해 타입 어설션은 as 문법을 이용하는 것이 좋습니다.</p>
<p>타입 어설션은 컴파일러에게 전달되는 타입 정보이므로 컴파일러는 타입 어설션을 보고 유효성을 검증합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNum = <span class="string">'2020'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 캐스팅</span></span><br><span class="line"><span class="keyword">let</span> num1 = +myNum;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>(myNum);</span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(myNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입 호환</span></span><br><span class="line"><span class="keyword">let</span> num4: <span class="built_in">number</span> = &lt;<span class="built_in">number</span>&gt;myNum;</span><br><span class="line"><span class="keyword">let</span> num5: <span class="built_in">number</span> = myNum <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>num1, num2, num3에서 시도한 타입 캐스팅은 컴파일러가 관여하지 않고 런타임에만 동작합니다. num4, num5 번수에 선언된 타입 어설션은 컴파일 단계에만 유효하므로 생성된 자바스크립트가 제거된 것을 확인할 수 있습니다.</p>
<h2 id="타입-호환"><a href="#타입-호환" class="headerlink" title="타입 호환"></a>타입 호환</h2><h3 id="프로그래밍-언어의-타입-시스템"><a href="#프로그래밍-언어의-타입-시스템" class="headerlink" title="프로그래밍 언어의 타입 시스템"></a>프로그래밍 언어의 타입 시스템</h3><p>프로그래밍 언어는 타입 시스템(type system)을 갖춤으로써 컴파일 시점에 타입 검사를 통해 타입에서 비롯되는 오류를 방지합니다. 프로그래밍 언어마다 타입 검사 시점이 다른데 타입 검사는 크게 다음과 같은 두 가지 방식으로 나뉩니다.</p>
<ul>
<li>동적 타입 검사(dynamic type checking)</li>
<li>정적 타입 검사(static type checking)</li>
</ul>
<p>자바스크립트 같은 동적 프로그래밍 언어는 런타임 시점에 동적 타입 검사를 수행하고, 타입스크립트 같은 정적 언어는 컴파일 시점에 정적 타입 검사를 수행합니다.</p>
<ul>
<li>구조 타입 시스템(structural type system)</li>
<li>명목 타입 시스템(nominal type system)</li>
</ul>
<p>구조 타입 시스템은 타입의 구조와 정의만 같다면 타입 호환이 가능합니다. 이와 달리 명목 타입 시스템은 타입 호환이 되려면 명시적으로 같은 타입이어야 합니다. 전통적인 C++나 자바 같은 언어는 명목 타입 시스템을 지원하지만, 타입스크립트는 명목 타입 시스템뿐 아니라 구조 타입 시스템도 지원합니다.</p>
<p>타입스크립트는 크게 네 부류의 타이핑 방식을 지원합니다.</p>
<ul>
<li>덕 타이핑(duck typing)</li>
<li>구조 타이핑(structural typing)</li>
<li>구조 서브타이핑(structural subtyping)</li>
<li>명목 타이핑(nominal typing)</li>
</ul>
<p>첫째는 덕 타이핑으로 런타임 시 동적으로 타입의 구조가 정해지는 타입 지정 방식입니다.</p>
<p>둘째는 구조 타이핑으로 타입의 구조만 같으면 서로 호환 가능한 타입 지정 방식입니다.</p>
<p>셋째는 구조 서브타이핑으로 구조가 부분적으로 같더라도 타입 호환만을 지원합니다.</p>
<p>마지막으로 명목 타이핑으로, 타입 구조뿐 아니라 타입까지 같아야 호환 가능한 타입 지정 방식입니다.</p>
<h3 id="덕-타이핑"><a href="#덕-타이핑" class="headerlink" title="덕 타이핑"></a>덕 타이핑</h3><p>덕 타이핑은 동적 타이핑 방식으로서 자바스크립트 코드의 런타임 시 동적으로 타이핑이 이뤄지는 타입 지정 방식입니다.</p>
<p>덕 타이핑은 동적으로 타입이 결정되므로 유연하지만 타입 안전성은 떨어집니다.</p>
<p>만약, 덕 타이핑을 할 때 타입 안전성을 강화하려면 인터페이스를 도입하면 됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DuckGoose &#123;</span><br><span class="line">  speak();</span><br><span class="line">  swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swim</span>(<span class="params">obj: DuckGoose</span>) </span>&#123;</span><br><span class="line">  obj.speak();</span><br><span class="line">  obj.swim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>매개변수로 입력될 객체의 행동은 인터페이스 타입(DuckGoose)으로 제한할 수 있습니다. 이때 인터페이스로 입력되는 객체의 클래스가 서브 클래스이고 슈퍼 클래스를 대체할 수 있을 때 서브타이핑(sub typing)이 됩니다.</p>
<h3 id="구조-타이핑"><a href="#구조-타이핑" class="headerlink" title="구조 타이핑"></a>구조 타이핑</h3><p>타입스크립트는 타입 안전성을 위해 컴파일 시간에 타입 검사를 수행합니다. 그러나 모든 타입에 타입 검사가 이뤄지는 것은 아닙니다.</p>
<h3 id="구조가-같은-클래스-간의-구조-타이핑"><a href="#구조가-같은-클래스-간의-구조-타이핑" class="headerlink" title="구조가 같은 클래스 간의 구조 타이핑"></a>구조가 같은 클래스 간의 구조 타이핑</h3><p>구조가 같은 클래스 간에는 서로 타입 호환이 가능해서 서로의 타입으로 구조 타이핑이 가능합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, weight: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">  name: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">speed: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal: Animal = <span class="keyword">new</span> Animal(<span class="string">'happy'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> bird: Bird = <span class="keyword">new</span> Bird(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">animal = bird;</span><br><span class="line">bird = animal;</span><br></pre></td></tr></table></figure>

<p>위의 예제에서는 Animal과 Bird 클래스의 멤버 변수가 같으므로 서로 타입 호환이 가능합니다. 그런테 생성자의 매개변수는 다릅니다. 하지만 생성자의 매개변수가 달라도 타입 호환이 되는 데는 문제가 없습니다. 생성자 매개변수는 접근 제한자가 설정되지 않아 생성자 내부에서만 사용할 수 있으므로 클래스 구조의 영향을 미치지 않기 때문입니다.</p>
<h3 id="구조가-같은-클래스-간의-구조-타이핑-상속-관계-고려"><a href="#구조가-같은-클래스-간의-구조-타이핑-상속-관계-고려" class="headerlink" title="구조가 같은 클래스 간의 구조 타이핑(상속 관계 고려)"></a>구조가 같은 클래스 간의 구조 타이핑(상속 관계 고려)</h3><p>부모를 가진 자식 클래스와 같은 구조의 클래스가 있다면 이 두 클래스는 구조 타이핑이 가능합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Member <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> grade: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Admin <span class="keyword">extends</span> Member &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MemberCard &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> grade: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin: Admin = <span class="keyword">new</span> Admin();</span><br><span class="line">admin = <span class="keyword">new</span> MemberCard();</span><br></pre></td></tr></table></figure>

<p>위 예제에서 Admin과 MemberCard 클래스는 상속 관계도 아니고 아무런 관계가 없습니다. 그러나 같은 구조의 멤버 변수를 가지고 있습니다. Admin 클래스가 Member와 Person 클래스의 멤버를 상속하므로 MemberCard 클래스와 동일한 멤버 변수를 갖게 됩니다. 따라서 서로의 타입으로 구조 타이핑이 가능합니다.</p>
<h3 id="구조가-같은-클래스와-인터페이스-간의-구조-타이핑"><a href="#구조가-같은-클래스와-인터페이스-간의-구조-타이핑" class="headerlink" title="구조가 같은 클래스와 인터페이스 간의 구조 타이핑"></a>구조가 같은 클래스와 인터페이스 간의 구조 타이핑</h3><p>클래스와 인터페이스의 구조가 같다면 타입 호환이 가능해 서로의 타입으로 구조 타이핑이 가능합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: Person;</span><br><span class="line">person = <span class="keyword">new</span> Employee();</span><br></pre></td></tr></table></figure>

<p>Employee 클래스와 Person 인터페이스는 명시적으로 서로 관계가 없지만 타입스크립트는 구조 타입 시스템을 지원하므로 인터페이스와 클래스의 구조만 같다면 상호 구조 타이핑이 가능합니다.</p>
<h2 id="구조-서브타이핑"><a href="#구조-서브타이핑" class="headerlink" title="구조 서브타이핑"></a>구조 서브타이핑</h2><p>구조 타이핑은 타입 구조가 같아야지만 타입 호환이 이뤄지지만, 구조 서브타이핑은 구조가 부분적으로 같더라도 타입 호환을 지원합니다.</p>
<h3 id="구조-서브타이핑의-조건"><a href="#구조-서브타이핑의-조건" class="headerlink" title="구조 서브타이핑의 조건"></a>구조 서브타이핑의 조건</h3><p>구조 서브타이핑은 하위 타입이 상위 타입으로만 호환되는 조건이 있습니다.</p>
<ul>
<li>상위 타입 <code>{ a: string, b: string }</code></li>
<li>하위 타입 <code>{ a: string, b: string, c: string }</code></li>
</ul>
<p>하위 타입은 상위 타입의 속성을 포함합니다. 이 때 “상위 타입 = 하위 타입”처럼 하위 타입을 상위 타입에 대입하는 것으로 구조 서브타이핑이 가능합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> upper = &#123; a: <span class="built_in">string</span>; b: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> sub = &#123; a: <span class="built_in">string</span>; b: <span class="built_in">string</span>; c: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectUpper: upper = &#123; a: <span class="string">'a'</span>, b: <span class="string">'b'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> objectSub: sub = &#123; a: <span class="string">'a'</span>, b: <span class="string">'b'</span>, c: <span class="string">'c'</span> &#125;;</span><br><span class="line">objectUpper = objectSub;</span><br><span class="line"><span class="built_in">console</span>.log(objectUpper);</span><br></pre></td></tr></table></figure>

<h3 id="타입은-없지만-구조가-일부-같은-변수-간의-구조-서브타이핑"><a href="#타입은-없지만-구조가-일부-같은-변수-간의-구조-서브타이핑" class="headerlink" title="타입은 없지만 구조가 일부 같은 변수 간의 구조 서브타이핑"></a>타입은 없지만 구조가 일부 같은 변수 간의 구조 서브타이핑</h3><p>구조가 일부 같으면 타입이 없더라도 변수 간의 구조 서브타이핑이 가능합니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> infoUpper = &#123; name: <span class="string">'hyeongyu'</span>, country: <span class="string">'korea'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> infoSub = &#123; name: <span class="string">'hyeongyu'</span>, country: <span class="string">'korea'</span>, gender: <span class="string">'M'</span> &#125;;</span><br><span class="line">infoUpper = infoSub;</span><br></pre></td></tr></table></figure>

<h3 id="구조가-일부-같은-객체와-인터페이스-간의-구조-서브타이핑"><a href="#구조가-일부-같은-객체와-인터페이스-간의-구조-서브타이핑" class="headerlink" title="구조가 일부 같은 객체와 인터페이스 간의 구조 서브타이핑"></a>구조가 일부 같은 객체와 인터페이스 간의 구조 서브타이핑</h3><p>객체 리터럴(객체)이 할당된 변수에 인터페이스 타입을 지정하면 해당 변수는 구조 서브타이핑이 적용됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GroupUpper &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> groupSub = &#123; name: <span class="string">'hyeongyu'</span>, id: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> groupUpper: GroupUpper;</span><br><span class="line">groupUpper = groupSub;</span><br></pre></td></tr></table></figure>

<p>groupUpper 변수는 서브타이핑이 적용되었기 때문에 할당 받은 객체의 id 속성에 접근할 수 없게 됩니다.</p>
<h2 id="명목-타이핑"><a href="#명목-타이핑" class="headerlink" title="명목 타이핑"></a>명목 타이핑</h2><p>명목 타이핑은 자바나 C++, C#과 같은 전통적인 언어에서 사용하는 타이핑 방식으로 명시적으로 지정된 타입 간에만 타입이 호환됩니다. 명목 타이핑에 대한 예로 <code>Enum</code>이 있습니다. 같은 Enum 타입으로 지정된 변수 간에만 타입이 호환됩니다.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EastAsia1 &#123;</span><br><span class="line">  korea = <span class="number">88</span>,</span><br><span class="line">  china = <span class="number">86</span>,</span><br><span class="line">  japan = <span class="number">81</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> EastAsia2 &#123;</span><br><span class="line">  korea = <span class="number">88</span>,</span><br><span class="line">  china = <span class="number">86</span>,</span><br><span class="line">  japan = <span class="number">81</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> east1: EastAsia1 = EastAsia1.china;</span><br><span class="line"><span class="keyword">let</span> east1: EastAsia2 = EastAsia1.korea;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let east1: EastAsia1 = EastAsia2.china;</span></span><br><span class="line"><span class="comment">// let east2: EastAsia2 = EastAsia1.korea;</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/typescript/" rel="tag"># typescript</a>
              <a href="/tags/type-assertion/" rel="tag"># type-assertion</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/20/typescript-advanced-type/" rel="prev" title="타입스크립트 스터디 6주차">
      <i class="fa fa-chevron-left"></i> 타입스크립트 스터디 6주차
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/17/typescript-aync-await/" rel="next" title="타입스크립트 스터디 8주차">
      타입스크립트 스터디 8주차 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#타입-선언과-변경-타입-호환"><span class="nav-number">1.</span> <span class="nav-text">타입 선언과 변경, 타입 호환</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#타입-선언과-변경"><span class="nav-number">1.1.</span> <span class="nav-text">타입 선언과 변경</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#타입-에일리어스"><span class="nav-number">1.2.</span> <span class="nav-text">타입 에일리어스</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#타입-에일리어스를-이용한-단일-타입-선언"><span class="nav-number">1.2.1.</span> <span class="nav-text">타입 에일리어스를 이용한 단일 타입 선언</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#타입-에일리어스를-이용한-유니언-타입-선언"><span class="nav-number">1.2.2.</span> <span class="nav-text">타입 에일리어스를 이용한 유니언 타입 선언</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#타입-에일리어스를-이용한-배열-타입-선언"><span class="nav-number">1.2.3.</span> <span class="nav-text">타입 에일리어스를 이용한 배열 타입 선언</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#타입-추론"><span class="nav-number">1.3.</span> <span class="nav-text">타입 추론</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#타입-캐스팅-변환-어설션"><span class="nav-number">1.4.</span> <span class="nav-text">타입 캐스팅, 변환, 어설션</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#타입-캐스팅과-변환"><span class="nav-number">1.4.1.</span> <span class="nav-text">타입 캐스팅과 변환</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#타입-어설션"><span class="nav-number">1.4.2.</span> <span class="nav-text">타입 어설션</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#타입-호환"><span class="nav-number">1.5.</span> <span class="nav-text">타입 호환</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#프로그래밍-언어의-타입-시스템"><span class="nav-number">1.5.1.</span> <span class="nav-text">프로그래밍 언어의 타입 시스템</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#덕-타이핑"><span class="nav-number">1.5.2.</span> <span class="nav-text">덕 타이핑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#구조-타이핑"><span class="nav-number">1.5.3.</span> <span class="nav-text">구조 타이핑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#구조가-같은-클래스-간의-구조-타이핑"><span class="nav-number">1.5.4.</span> <span class="nav-text">구조가 같은 클래스 간의 구조 타이핑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#구조가-같은-클래스-간의-구조-타이핑-상속-관계-고려"><span class="nav-number">1.5.5.</span> <span class="nav-text">구조가 같은 클래스 간의 구조 타이핑(상속 관계 고려)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#구조가-같은-클래스와-인터페이스-간의-구조-타이핑"><span class="nav-number">1.5.6.</span> <span class="nav-text">구조가 같은 클래스와 인터페이스 간의 구조 타이핑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#구조-서브타이핑"><span class="nav-number">1.6.</span> <span class="nav-text">구조 서브타이핑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#구조-서브타이핑의-조건"><span class="nav-number">1.6.1.</span> <span class="nav-text">구조 서브타이핑의 조건</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#타입은-없지만-구조가-일부-같은-변수-간의-구조-서브타이핑"><span class="nav-number">1.6.2.</span> <span class="nav-text">타입은 없지만 구조가 일부 같은 변수 간의 구조 서브타이핑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#구조가-일부-같은-객체와-인터페이스-간의-구조-서브타이핑"><span class="nav-number">1.6.3.</span> <span class="nav-text">구조가 일부 같은 객체와 인터페이스 간의 구조 서브타이핑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#명목-타이핑"><span class="nav-number">1.7.</span> <span class="nav-text">명목 타이핑</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Goofy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Goofy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-hyeongyuan-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://hyeongyuan.github.io/2020/06/03/typescript-type-assertion/";
    this.page.identifier = "2020/06/03/typescript-type-assertion/";
    this.page.title = "타입스크립트 스터디 7주차";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://https-hyeongyuan-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
